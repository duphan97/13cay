<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng D·ª•ng Ghi ƒêi·ªÉm Tr√≤ Ch∆°i</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#4f46e5', // Indigo 600
                        'secondary': '#10b981', // Emerald 500
                        'warning': '#f59e0b', // Amber 500
                        'danger': '#ef4444', // Red 500
                    },
                }
            }
        }
    </script>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        @keyframes bounce-in {
            0%, 20%, 40%, 60%, 80%, 100% {
                transition-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
            }
            0% { opacity: 0; transform: scale3d(.3, .3, .3); }
            40% { transform: scale3d(1.1, 1.1, 1.1); }
            80% { transform: scale3d(.97, .97, .97); }
            100% { opacity: 1; transform: scale3d(1, 1, 1); }
        }
        .animate-bounce-in {
            animation: bounce-in 0.8s;
        }
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fade-in 0.3s ease-out;
        }
        .animate-pulse-slow {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;
        const MAX_PLAYERS = 4;
        
        // C·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n cho √¢m thanh c·ª•c b·ªô
        const AUDIO_BASE_PATH = 'audio/';
        
        /* * DANH S√ÅCH FILE AUDIO C·∫¶N C√ì TRONG TH∆Ø M·ª§C 'audio/':
        * 1. H·ªá th·ªëng: vanmoi.mp3, dacong.mp3, datru.mp3, colen.mp3, chiabuon.mp3, va.mp3, dathua.mp3
        * 2. S·ªë ƒëi·ªÉm: 0.mp3, 1.mp3, 2.mp3, ... (cho c√°c s·ªë ƒëi·ªÉm th∆∞·ªùng g·∫∑p)
        * 3. T√™n ng∆∞·ªùi ch∆°i: binhdang.mp3, dunghoang.mp3, dungnguyen.mp3, duphan.mp3, dongle.mp3, v.v.
        */

        // Danh s√°ch t√™n ng∆∞·ªùi ch∆°i c√≥ s·∫µn
        const PRESET_PLAYERS = ["B√¨nh ƒê·∫∑ng", "D≈©ng Ho√†ng", "D≈©ng Nguy·ªÖn", "D·ª± Phan", "ƒê√¥ng L√™"];
        const PRESET_ROUNDS = [15, 21, 31];

        // --- 1. Custom Hooks & Utilities ---

        // H√†m chu·∫©n h√≥a t√™n ng∆∞·ªùi ch∆°i th√†nh t√™n file kh√¥ng d·∫•u, kh√¥ng kho·∫£ng tr·∫Øng, ch·ªØ th∆∞·ªùng
        const normalizeName = (name) => {
            // Lo·∫°i b·ªè d·∫•u ti·∫øng Vi·ªát (NFD and combining marks regex)
            return name
                .normalize('NFD').replace(/[\u0300-\u036f]/g, "") 
                .toLowerCase()
                .replace(/\s+/g, ''); // Lo·∫°i b·ªè kho·∫£ng tr·∫Øng
        };

        // Custom Hook: X·ª≠ l√Ω Audio theo h√†ng ƒë·ª£i (ƒê·∫£m b·∫£o kh√¥ng b·ªã ch·ªìng ch√©o V√Ä T·∫¢I TR∆Ø·ªöC)
        const useAudioQueue = () => {
            // H√†ng ƒë·ª£i l∆∞u tr·ªØ c√°c M·∫¢NG C√ÅC ƒê·ªêI T∆Ø·ª¢NG AUDIO ƒë√£ ƒë∆∞·ª£c t·∫£i (preloaded Audio objects)
            const audioQueue = useRef([]); 
            const isPlaying = useRef(false); // C·ªù tr·∫°ng th√°i: ƒêang ph√°t hay kh√¥ng?

            // H√†m t·∫£i tr∆∞·ªõc v√† tr·∫£ v·ªÅ m·ªôt promise (ho·∫∑c m·ªôt m·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng Audio)
            const preloadAudioSequence = useCallback((soundNames) => {
                const audioObjects = soundNames.map(name => {
                    const fullPath = `${AUDIO_BASE_PATH}${name}.mp3`;
                    const audio = new Audio(fullPath);
                    audio.volume = 0.8;
                    return audio;
                });

                // Promise.all ch·ªù t·∫•t c·∫£ c√°c file load th√†nh c√¥ng
                const loadPromises = audioObjects.map(audio => new Promise((resolve, reject) => {
                    // N·∫øu ƒë√£ s·∫µn s√†ng (cached/loaded), resolve ngay
                    if (audio.readyState >= 2) { // 2 = Have enough data
                        resolve();
                        return;
                    }
                    
                    // S·ª± ki·ªán 'canplaythrough' ƒë·∫£m b·∫£o file ƒë√£ ƒë∆∞·ª£c t·∫£i ƒë·ªß ƒë·ªÉ ph√°t m√† kh√¥ng b·ªã ng·∫Øt qu√£ng
                    audio.addEventListener('canplaythrough', resolve, { once: true });
                    
                    // X·ª≠ l√Ω l·ªói t·∫£i file
                    audio.addEventListener('error', (e) => {
                        console.warn(`L·ªói t·∫£i file: ${audio.src}. Chu·ªói ph√°t n√†y s·∫Ω b·ªã b·ªè qua.`);
                        // B·∫•t k·ª≥ l·ªói n√†o c≈©ng l√†m h·ªèng to√†n b·ªô chu·ªói
                        reject(new Error(`Failed to load ${audio.src}`));
                    }, { once: true });
                    
                    // B·∫Øt ƒë·∫ßu t·∫£i
                    audio.load();
                }));

                return Promise.all(loadPromises)
                    .then(() => audioObjects) // Tr·∫£ v·ªÅ m·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng Audio ƒë√£ ƒë∆∞·ª£c t·∫£i
                    .catch(error => {
                        // N·∫øu c√≥ l·ªói, tr·∫£ v·ªÅ m·∫£ng r·ªóng ƒë·ªÉ b√°o hi·ªáu b·ªè qua chu·ªói n√†y
                        console.error('To√†n b·ªô chu·ªói ph√°t √¢m thanh n√†y b·ªã b·ªè qua do l·ªói t·∫£i file.', error.message);
                        return []; 
                    });

            }, []);

            const playNext = useCallback(() => {
                // Ch·ªâ ph√°t n·∫øu c√≤n file trong h√†ng ƒë·ª£i V√Ä hi·ªán t·∫°i KH√îNG c√≥ file n√†o ƒëang ph√°t
                if (audioQueue.current.length > 0 && !isPlaying.current) {
                    isPlaying.current = true;
                    // L·∫•y to√†n b·ªô m·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng Audio ƒë√£ ƒë∆∞·ª£c t·∫£i ra kh·ªèi h√†ng ƒë·ª£i
                    const currentSequence = audioQueue.current.shift(); 
                    let currentAudioIndex = 0;

                    // H√†m ƒë·ªá quy ph√°t l·∫ßn l∆∞·ª£t t·ª´ng file trong chu·ªói
                    const playSequence = () => {
                        if (currentAudioIndex >= currentSequence.length) {
                            // K·∫øt th√∫c chu·ªói, m·ªü kh√≥a v√† chuy·ªÉn sang chu·ªói ti·∫øp theo
                            isPlaying.current = false; 
                            playNext(); 
                            return;
                        }

                        const audio = currentSequence[currentAudioIndex];
                        
                        // ƒê·∫∑t s·ª± ki·ªán onended tr∆∞·ªõc khi play
                        audio.onended = () => {
                            currentAudioIndex++;
                            // Ch∆°i li·ªÅn m·∫°ch (delay 0ms), g·ªçi playSequence() ngay
                            playSequence(); 
                        };

                        // B·∫Øt ƒë·∫ßu ph√°t
                        audio.play().catch(e => {
                            console.warn("Autoplay was prevented or playback error:", audio.src, e);
                            // N·∫øu l·ªói ph√°t, chuy·ªÉn sang file ti·∫øp theo
                            currentAudioIndex++;
                            playSequence();
                        });
                    };

                    // B·∫Øt ƒë·∫ßu ph√°t chu·ªói
                    if (currentSequence.length > 0) {
                        playSequence();
                    } else {
                        // N·∫øu chu·ªói r·ªóng (do l·ªói t·∫£i), chuy·ªÉn sang chu·ªói ti·∫øp theo ngay l·∫≠p t·ª©c
                        isPlaying.current = false;
                        playNext();
                    }
                }
            }, []);

            // Th√™m m·ªôt ho·∫∑c nhi·ªÅu T√äN file v√†o h√†ng ƒë·ª£i (s·∫Ω ƒë∆∞·ª£c preload)
            const addToQueue = useCallback((soundNamesArray) => {
                // soundNamesArray l√† m·ªôt m·∫£ng ch·ª©a T√äN file (vd: ['vanmoi'] ho·∫∑c ['dacong', '5', 'binhdang'])
                
                // 1. T·∫£i tr∆∞·ªõc v√† th√™m v√†o h√†ng ƒë·ª£i
                const loadingPromise = preloadAudioSequence(soundNamesArray)
                    .then(preloadedAudioObjects => {
                        if (preloadedAudioObjects.length > 0) {
                            audioQueue.current.push(preloadedAudioObjects);
                        }
                    })
                    .finally(() => {
                        // 2. B·∫Øt ƒë·∫ßu chu tr√¨nh ph√°t (n·∫øu ch∆∞a ph√°t)
                        if (!isPlaying.current) {
                            playNext();
                        }
                    });

                return loadingPromise; // Tr·∫£ v·ªÅ promise ƒë·ªÉ theo d√µi qu√° tr√¨nh t·∫£i
            }, [playNext, preloadAudioSequence]);


            // ƒê·ªëi v·ªõi logic ƒë·ªçc ƒëi·ªÉm (nhi·ªÅu ng∆∞·ªùi ch∆°i), ta c·∫ßn m·ªôt h√†m gom c√°c chu·ªói l·∫°i:
            const addMultipleSequencesToQueue = useCallback((sequences) => {
                let initialPlayTriggered = false;
                
                // T·∫°o m·ªôt m·∫£ng promises ƒë·ªÉ ch·ªù t·∫•t c·∫£ c√°c chu·ªói t·∫£i xong
                const allSequencesLoaded = sequences.map(soundNamesArray => {
                     return preloadAudioSequence(soundNamesArray)
                        .then(preloadedAudioObjects => {
                            if (preloadedAudioObjects.length > 0) {
                                audioQueue.current.push(preloadedAudioObjects);
                                // K√≠ch ho·∫°t ph√°t l·∫ßn ƒë·∫ßu ngay sau khi chu·ªói ƒë·∫ßu ti√™n ƒë∆∞·ª£c t·∫£i
                                if (!isPlaying.current && !initialPlayTriggered) {
                                    initialPlayTriggered = true;
                                    playNext();
                                }
                            }
                        });
                });

                // Ch·ªù t·∫•t c·∫£ promises ho√†n th√†nh tr∆∞·ªõc khi g·ªçi playNext() m·ªôt l·∫ßn cu·ªëi ƒë·ªÉ ƒë·∫£m b·∫£o h√†ng ƒë·ª£i kh√¥ng b·ªã b·ªè s√≥t
                Promise.all(allSequencesLoaded).finally(() => {
                    if (!isPlaying.current) {
                        playNext();
                    }
                });

            }, [playNext, preloadAudioSequence]);


            return { 
                addToQueue: addToQueue, // D√πng cho c√°c l·ªánh ƒë∆°n l·∫ª (vd: 'vanmoi')
                addMultipleSequencesToQueue: addMultipleSequencesToQueue // D√πng cho logic ƒë·ªçc ƒëi·ªÉm (nhi·ªÅu chu·ªói li·ªÅn nhau)
            };
        };


        // Custom Hook: Qu·∫£n l√Ω State v·ªõi LocalStorage
        const useLocalStorageState = (key, defaultValue) => {
            const [state, setState] = useState(() => {
                const storedValue = localStorage.getItem(key);
                try {
                    return storedValue ? JSON.parse(storedValue) : defaultValue;
                } catch (e) {
                    console.error("L·ªói khi parse localStorage:", e);
                    return defaultValue;
                }
            });

            useEffect(() => {
                try {
                    localStorage.setItem(key, JSON.stringify(state));
                } catch (e) {
                    console.error("L·ªói khi l∆∞u v√†o localStorage:", e);
                }
            }, [key, state]);

            return [state, setState];
        };

        // H√†m t·∫°o ID duy nh·∫•t
        const generateId = () => Math.random().toString(36).substring(2, 9);
        
        // --- 2. Component Con: Modal (Thay th·∫ø alert/confirm) ---

        const Modal = ({ title, content, isOpen, onClose, onConfirm, confirmText = "X√°c nh·∫≠n", cancelText = "H·ªßy b·ªè", showCancel = true }) => {
            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 animate-fade-in">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-sm animate-bounce-in">
                        <header className="px-4 py-3 bg-primary rounded-t-xl">
                            <h3 className="text-xl font-bold text-white">{title}</h3>
                        </header>
                        <div className="p-4">
                            {content}
                        </div>
                        <footer className="flex justify-end space-x-3 p-4 border-t border-gray-100">
                            {showCancel && (
                                <button
                                    onClick={onClose}
                                    className="px-4 py-2 text-sm font-semibold text-gray-700 bg-gray-200 rounded-lg transition"
                                >
                                    {cancelText}
                                </button>
                            )}
                            <button
                                onClick={onConfirm}
                                className="px-4 py-2 text-sm font-semibold text-white bg-secondary rounded-lg transition"
                            >
                                {confirmText}
                            </button>
                        </footer>
                    </div>
                </div>
            );
        };

        // --- 3. Component Ch√≠nh: App ---

        function App() {
            // State ch√≠nh c·ªßa ·ª©ng d·ª•ng
            const [gameState, setGameState] = useLocalStorageState('gameState', 'setup'); // 'setup', 'playing', 'game_over'
            const [players, setPlayers] = useLocalStorageState('players', []);
            // maxRounds c√≥ th·ªÉ l√† string ('') ho·∫∑c number
            const [maxRounds, setMaxRounds] = useLocalStorageState('maxRounds', 15); 
            const [history, setHistory] = useLocalStorageState('history', []);
            const [showHistory, setShowHistory] = useState(false);
            const [isScoringMode, setIsScoringMode] = useState(false);
            const [newPlayerName, setNewPlayerName] = useState('');
            const [roundScoreInputs, setRoundScoreInputs] = useLocalStorageState('roundScoreInputs', {}); // Gi·ªØ l·∫°i gi√° tr·ªã khi refresh
            const [modal, setModal] = useState({ isOpen: false, type: null, data: null });
            const [newMaxRoundsInput, setNewMaxRoundsInput] = useState(15);
            
            const { addToQueue, addMultipleSequencesToQueue } = useAudioQueue(); // Hook qu·∫£n l√Ω h√†ng ƒë·ª£i √¢m thanh

            // T√≠nh to√°n t·ªïng ƒëi·ªÉm v√† b·∫£ng x·∫øp h·∫°ng
            const playerScores = useMemo(() => {
                const roundsLimit = parseInt(maxRounds) || 15; // D√πng maxRounds ƒë√£ parse cho an to√†n
                return players.map(p => {
                    const totalScore = history.reduce((sum, round) => sum + (round.scores[p.id] || 0), 0);
                    return { ...p, totalScore };
                }).sort((a, b) => b.totalScore - a.totalScore); // S·∫Øp x·∫øp t·ª´ cao xu·ªëng th·∫•p
            }, [players, history, maxRounds]);

            // --- Logic Audio 4. Ph√°t √¢m thanh ƒë·ªçc ƒëi·ªÉm (ƒê√£ t·ªëi ∆∞u) ---
            const playScoreAudio = (currentRoundScores) => {
                // T·∫°o m·∫£ng chi ti·∫øt ƒëi·ªÉm, c√≥ ƒëi·ªÉm v√°n v·ª´a ghi
                const scoreDetails = playerScores.map(p => ({
                    name: p.name,
                    score: currentRoundScores[p.id] || 0,
                    id: p.id
                }));
                
                // S·∫Øp x·∫øp theo ƒëi·ªÉm v√°n v·ª´a ghi (cao -> th·∫•p)
                scoreDetails.sort((a, b) => b.score - a.score);

                let allAudioSequences = [];
                
                scoreDetails.forEach(detail => {
                    const absScore = Math.abs(detail.score);
                    const nameFile = normalizeName(detail.name); // T√™n ng∆∞·ªùi ch∆°i chu·∫©n h√≥a
                    const scoreStr = absScore.toString(); // S·ªë ƒëi·ªÉm (v√≠ d·ª•: '5', '10')

                    let audioSequence = [];

                    if (detail.score > 0) {
                        // ƒêI·ªÇM D∆Ø∆†NG: 'dacong', [Absolute Score file], [Name file]
                        audioSequence = ['dacong', scoreStr, nameFile]; 
                    } else if (detail.score < 0) {
                        // ƒêI·ªÇM √ÇM: 'datru', [Absolute Score file], [Name file], 'colen'
                        audioSequence = ['datru', scoreStr, nameFile, 'colen'];
                    } else {
                        // ƒêI·ªÇM B·∫∞NG 0: [Name file], '0', 'colen'
                        audioSequence = [nameFile, '0', 'colen'];
                    }
                    
                    // Th√™m chu·ªói ph√°t c·ªßa ng∆∞·ªùi ch∆°i n√†y v√†o danh s√°ch t·ªïng
                    allAudioSequences.push(audioSequence);
                });
                
                // G·ª≠i t·∫•t c·∫£ c√°c chu·ªói ƒë·ªÉ ƒë∆∞·ª£c t·∫£i tr∆∞·ªõc v√† ph√°t li·ªÅn m·∫°ch
                addMultipleSequencesToQueue(allAudioSequences);
            };

            // Logic Audio 6. K·∫øt th√∫c tr√≤ ch∆°i (ƒê√£ t·ªëi ∆∞u)
            const playGameOverAudio = (sortedPlayers) => {
                if (sortedPlayers.length < 2) return;
                
                // Ng∆∞·ªùi √≠t ƒëi·ªÉm nh·∫•t l√† ng∆∞·ªùi cu·ªëi c√πng trong m·∫£ng ƒë√£ s·∫Øp x·∫øp (th·∫•p ƒëi·ªÉm)
                const lastPlayer = sortedPlayers[sortedPlayers.length - 1];
                const secondLastPlayer = sortedPlayers[sortedPlayers.length - 2];

                const lastPlayerName = normalizeName(lastPlayer.name);
                const secondLastPlayerName = normalizeName(secondLastPlayer.name);

                // Format: chiabuon.mp3 + T√™n ng∆∞·ªùi 1 + va.mp3 + T√™n ng∆∞·ªùi 2 + dathua.mp3
                const audioSequence = [
                    'chiabuon', 
                    lastPlayerName, 
                    'va', 
                    secondLastPlayerName, 
                    'dathua'
                ];
                
                // S·ª≠ d·ª•ng addToQueue cho l·ªánh ƒë∆°n (d√π n√≥ l√† m·ªôt chu·ªói)
                addToQueue(audioSequence);
            };

            // --- 5. L·ªãch s·ª≠ ƒëi·ªÉm v√† T·ªïng k·∫øt v√°n ---
            useEffect(() => {
                const roundsLimit = parseInt(maxRounds);
                if (gameState === 'playing' && history.length > 0 && roundsLimit > 0 && history.length >= roundsLimit) {
                    setGameState('game_over');
                    // T√≠nh l·∫°i playerScores cu·ªëi c√πng tr∆∞·ªõc khi ph√°t audio k·∫øt th√∫c
                    const finalPlayerScores = players.map(p => {
                        const totalScore = history.reduce((sum, round) => sum + (round.scores[p.id] || 0), 0);
                        return { ...p, totalScore };
                    }).sort((a, b) => b.totalScore - a.totalScore);
                    
                    playGameOverAudio(finalPlayerScores);
                }
            }, [history, maxRounds, gameState, players]);
            
            // Kh·ªüi t·∫°o/C·∫≠p nh·∫≠t input scores khi players thay ƒë·ªïi (sau khi load state t·ª´ localStorage)
            useEffect(() => {
                 if (players.length > 0 && gameState === 'playing' && Object.keys(roundScoreInputs).length === 0) {
                    const initialInputs = players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                    setRoundScoreInputs(initialInputs);
                }
            }, [players, gameState, roundScoreInputs]);


            // --- 7. Ho√†n t√°c (Undo) ---
            const handleUndo = () => {
                if (history.length === 0) return;

                setModal({
                    isOpen: true,
                    type: 'confirm_undo',
                    data: { message: `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën ho√†n t√°c V√°n ${history.length} kh√¥ng?` }
                });
            };

            const confirmUndo = () => {
                setHistory(prev => prev.slice(0, -1)); // X√≥a v√°n cu·ªëi c√πng
                setGameState('playing');
                setIsScoringMode(false);
                setRoundScoreInputs({});
                setModal({ isOpen: false, type: null, data: null });
            };


            // --- X·ª≠ l√Ω Stage: Setup (Giai ƒëo·∫°n I) ---

            const handlePlayerToggle = (player) => {
                const newPlayers = players.find(p => p.id === player.id) 
                    ? players.filter(p => p.id !== player.id)
                    : [...players, player];
                
                if (newPlayers.length > MAX_PLAYERS) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Th√¥ng b√°o', message: `S·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i t·ªëi ƒëa l√† ${MAX_PLAYERS}.` }
                    });
                    return;
                }
                setPlayers(newPlayers);
            };

            const handleAddNewPlayer = () => {
                if (newPlayerName && players.length < MAX_PLAYERS) {
                    // Ki·ªÉm tra tr√πng t√™n (Kh√¥ng b·∫Øt bu·ªôc theo y√™u c·∫ßu, nh∆∞ng n√™n c√≥)
                    if (players.some(p => p.name.toLowerCase() === newPlayerName.trim().toLowerCase())) {
                         setModal({
                            isOpen: true,
                            type: 'info',
                            data: { title: 'Th√¥ng b√°o', message: `Ng∆∞·ªùi ch∆°i '${newPlayerName}' ƒë√£ t·ªìn t·∫°i.` }
                        });
                        return;
                    }
                    
                    const normalizedName = normalizeName(newPlayerName);
                    // D√πng t√™n chu·∫©n h√≥a l√†m ID n·∫øu ch∆∞a t·ªìn t·∫°i
                    const newPlayer = { id: normalizedName + generateId(), name: newPlayerName.trim() }; // Th√™m ID ng·∫´u nhi√™n ƒë·ªÉ tr√°nh tr√πng v·ªõi PRESET
                    setPlayers([...players, newPlayer]);
                    setNewPlayerName('');
                } else if (players.length >= MAX_PLAYERS) {
                     setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Th√¥ng b√°o', message: `S·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i t·ªëi ƒëa l√† ${MAX_PLAYERS}.` }
                    });
                }
            };
            
            const handleStartGame = () => {
                if (players.length < 2) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'L·ªói', message: 'C·∫ßn t·ªëi thi·ªÉu 2 ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu tr√≤ ch∆°i.' }
                    });
                    return;
                }
                
                // Logic x·ª≠ l√Ω khi maxRounds l√† string (khi ng∆∞·ªùi d√πng x√≥a input)
                const finalMaxRounds = parseInt(maxRounds);
                if (isNaN(finalMaxRounds) || finalMaxRounds < 1) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'L·ªói', message: 'S·ªë v√°n ch∆°i ph·∫£i l√† m·ªôt s·ªë nguy√™n d∆∞∆°ng h·ª£p l·ªá (t·ªëi thi·ªÉu 1).' }
                    });
                    setMaxRounds(15); // Reset v·ªÅ m·∫∑c ƒë·ªãnh
                    return;
                }

                setMaxRounds(finalMaxRounds); // ƒê·∫£m b·∫£o state maxRounds l√† number
                setGameState('playing');
                // Kh·ªüi t·∫°o c√°c input ƒëi·ªÉm v√°n = 0 (d·ª±a tr√™n players m·ªõi)
                const initialInputs = players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                setRoundScoreInputs(initialInputs);
            };


            // --- X·ª≠ l√Ω Stage: Playing (Giai ƒëo·∫°n II) ---

            // 3. N√∫t ‚ÄúGhi ƒëi·ªÉm v√°n m·ªõi‚Äù
            const handleNewScoreClick = () => {
                if (!isScoringMode) {
                    addToQueue(['vanmoi']); // CH·ªà PH√ÅT L·∫¶N 1
                    setIsScoringMode(true);
                    // Reset input scores to 0 when entering scoring mode
                    const initialInputs = playerScores.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                    setRoundScoreInputs(initialInputs);
                } else {
                    // X√°c nh·∫≠n ghi ƒëi·ªÉm
                    handleConfirmScore();
                }
            };

            const handleScoreChange = (playerId, value) => {
                const numValue = value === '' ? '' : parseInt(value);
                // Gi·ªØ l·∫°i gi√° tr·ªã string r·ªóng n·∫øu user x√≥a h·∫øt
                setRoundScoreInputs(prev => ({ ...prev, [playerId]: isNaN(numValue) ? value : numValue }));
            };

            const handleConfirmScore = () => {
                const newRoundScores = {};

                // Chu·∫©n h√≥a ƒëi·ªÉm
                playerScores.forEach(p => {
                    const score = roundScoreInputs[p.id];
                    // N·∫øu gi√° tr·ªã l√† '' (string r·ªóng) ho·∫∑c null, NaN th√¨ g√°n 0
                    if (score === '' || score === null || isNaN(score)) {
                        newRoundScores[p.id] = 0; 
                    } else {
                        newRoundScores[p.id] = parseInt(score); // ƒê·∫£m b·∫£o l√† s·ªë nguy√™n
                    }
                });

                // Ghi k·∫øt qu·∫£ v√†o l·ªãch s·ª≠
                const newHistoryEntry = {
                    round: history.length + 1,
                    scores: newRoundScores,
                    timestamp: new Date().toISOString()
                };
                setHistory(prev => [...prev, newHistoryEntry]);

                // Ph√°t √¢m thanh theo logic m·ªõi
                playScoreAudio(newRoundScores);

                // Reset tr·∫°ng th√°i
                setIsScoringMode(false);
                setRoundScoreInputs({});
            };
            
            // 8. Set l·∫°i s·ªë v√°n ch∆°i
            const handleSetRoundsClick = () => {
                 setModal({
                    isOpen: true,
                    type: 'reset_rounds',
                    data: { currentMax: parseInt(maxRounds) || 15, playedRounds: history.length }
                });
                setNewMaxRoundsInput(parseInt(maxRounds) || 15);
            };

            const confirmResetRounds = () => {
                const newMax = parseInt(newMaxRoundsInput);
                if (isNaN(newMax) || newMax <= 0) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'L·ªói', message: 'S·ªë v√°n m·ªõi ph·∫£i l√† m·ªôt s·ªë nguy√™n d∆∞∆°ng h·ª£p l·ªá.' }
                    });
                    return;
                }
                if (newMax < history.length) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'L·ªói', message: `S·ªë v√°n m·ªõi (${newMax}) kh√¥ng ƒë∆∞·ª£c nh·ªè h∆°n s·ªë v√°n ƒë√£ ch∆°i (${history.length}).` }
                    });
                    return;
                }
                setMaxRounds(newMax);
                setModal({ isOpen: false, type: null, data: null });
                if (history.length >= newMax) {
                    setGameState('game_over');
                    
                    // T√≠nh l·∫°i playerScores cu·ªëi c√πng tr∆∞·ªõc khi ph√°t audio k·∫øt th√∫c
                    const finalPlayerScores = players.map(p => {
                        const totalScore = history.reduce((sum, round) => sum + (round.scores[p.id] || 0), 0);
                        return { ...p, totalScore };
                    }).sort((a, b) => b.totalScore - a.totalScore);
                    
                    playGameOverAudio(finalPlayerScores);
                }
            };

            const renderModalContent = () => {
                switch (modal.type) {
                    case 'info':
                        return <div><p className="text-gray-700">{modal.data.message}</p></div>;
                    case 'confirm_undo':
                        return <div><p className="text-gray-700">{modal.data.message}</p></div>;
                    case 'reset_rounds':
                        return (
                            <div>
                                <p className="text-gray-700 mb-4">
                                    V√°n ƒë√£ ch∆°i: <span className="font-bold text-primary">{modal.data.playedRounds}</span>.
                                    S·ªë v√°n t·ªëi thi·ªÉu ph·∫£i l√† <span className="font-bold text-primary">{modal.data.playedRounds}</span>.
                                </p>
                                <label className="block text-sm font-medium text-gray-700">Nh·∫≠p s·ªë v√°n m·ªõi:</label>
                                <input
                                    type="number"
                                    min={modal.data.playedRounds}
                                    value={newMaxRoundsInput}
                                    onChange={(e) => setNewMaxRoundsInput(e.target.value)}
                                    className="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:ring-primary focus:border-primary"
                                />
                            </div>
                        );
                    default:
                        return null;
                }
            };

            // --- Render c√°c Stage ---
            
            // Stage 0: Setup (ƒê√£ t·ªëi ∆∞u giao di·ªán)
            const renderSetup = () => (
                <div className="p-4 sm:p-6 pb-2">
                    <h2 className="text-xl font-bold text-primary mb-4 text-center">‚öôÔ∏è C·∫•u H√¨nh Tr√≤ Ch∆°i</h2>

                    {/* Ch·ªçn S·ªë V√°n (C√πng h√†ng) */}
                    <div className="mb-4 p-3 bg-white rounded-lg shadow-sm border border-gray-200">
                        <h3 className="text-md font-semibold mb-2 text-gray-700">1. Ch·ªçn S·ªë V√°n Ch∆°i (Hi·ªán t·∫°i: {parseInt(maxRounds) || 15})</h3>
                        <div className="flex flex-wrap gap-2 mb-2">
                            {PRESET_ROUNDS.map(r => (
                                <button
                                    key={r}
                                    onClick={() => setMaxRounds(r)}
                                    className={`px-3 py-1 text-sm font-medium rounded-full transition ${parseInt(maxRounds) === r ? 'bg-primary text-white shadow-md' : 'bg-gray-200 text-gray-700'}`}
                                >
                                    {r} V√°n
                                </button>
                            ))}
                        </div>
                        <input
                            type="number"
                            min="1"
                            value={maxRounds} // C√≥ th·ªÉ l√† string '' ho·∫∑c number
                            onChange={(e) => setMaxRounds(e.target.value)} // Ch·∫•p nh·∫≠n string r·ªóng ƒë·ªÉ user c√≥ th·ªÉ x√≥a
                            onBlur={(e) => {
                                const val = parseInt(e.target.value);
                                if (isNaN(val) || val < 1) {
                                    setMaxRounds(1); // Set minimum to 1 if empty or invalid on blur
                                } else {
                                     setMaxRounds(val); // Ensure it's stored as a number on blur
                                }
                            }}
                            className="w-full p-2 border border-gray-300 rounded-lg text-sm mt-1 focus:ring-secondary focus:border-secondary"
                        />
                    </div>
                    
                    {/* Ch·ªçn Ng∆∞·ªùi Ch∆°i */}
                    <div className="mb-4 p-3 bg-white rounded-lg shadow-sm border border-gray-200">
                        <h3 className="text-md font-semibold mb-2 text-gray-700">2. Ch·ªçn Ng∆∞·ªùi Ch∆°i</h3>
                        
                        {/* Danh s√°ch ch·ªçn s·∫µn */}
                        <div className="flex flex-wrap gap-2 border-b pb-3 mb-3">
                            {PRESET_PLAYERS.map(name => {
                                // S·ª≠ d·ª•ng t√™n chu·∫©n h√≥a l√†m ID
                                const id = normalizeName(name);
                                // T·∫°o ID duy nh·∫•t cho ng∆∞·ªùi ch∆°i preset
                                const player = { id: id, name: name }; 
                                const isSelected = players.some(p => p.id === id);
                                return (
                                    <button
                                        key={name}
                                        onClick={() => handlePlayerToggle(player)}
                                        className={`px-3 py-1 text-sm rounded-full transition ${isSelected ? 'bg-secondary text-white font-semibold shadow-sm' : 'bg-gray-100 text-gray-600'} disabled:opacity-50`}
                                        disabled={!isSelected && players.length >= MAX_PLAYERS}
                                    >
                                        {name} {isSelected ? '‚úÖ' : ''}
                                    </button>
                                );
                            })}
                        </div>

                        {/* Th√™m ng∆∞·ªùi ch∆°i m·ªõi */}
                        <div className="flex space-x-2">
                            <input
                                type="text"
                                value={newPlayerName}
                                onChange={(e) => setNewPlayerName(e.target.value)}
                                placeholder="T√™n ng∆∞·ªùi ch∆°i m·ªõi..."
                                className="flex-grow p-2 text-sm border border-gray-300 rounded-lg focus:ring-primary focus:border-primary"
                                disabled={players.length >= MAX_PLAYERS}
                            />
                            <button
                                onClick={handleAddNewPlayer}
                                className="p-2 bg-primary text-white rounded-lg font-semibold text-sm transition disabled:bg-gray-400"
                                disabled={!newPlayerName.trim() || players.length >= MAX_PLAYERS}
                            >
                                Th√™m
                            </button>
                        </div>
                        
                    </div>

                    {/* Danh s√°ch ng∆∞·ªùi ch∆°i ƒë√£ ch·ªçn */}
                    <div className="mb-4 p-3 bg-indigo-50 rounded-lg border border-indigo-200">
                        <h3 className="text-md font-semibold text-primary mb-2">Ng∆∞·ªùi ch∆°i ƒë√£ ch·ªçn ({players.length}/{MAX_PLAYERS}):</h3>
                        <div className="flex flex-wrap gap-2">
                            {players.map(p => (
                                <span key={p.id} className="bg-primary text-white text-xs px-3 py-1 rounded-full flex items-center">
                                    {p.name}
                                    <button 
                                        onClick={() => handlePlayerToggle(p)}
                                        className="ml-2 text-white/80 font-bold text-xs"
                                    >
                                        &times;
                                    </button>
                                </span>
                            ))}
                        </div>
                        {players.length === 0 && <p className="text-sm text-gray-500 italic mt-2">Ch∆∞a c√≥ ng∆∞·ªùi ch∆°i n√†o ƒë∆∞·ª£c ch·ªçn.</p>}
                    </div>

                    {/* N√∫t B·∫Øt ƒë·∫ßu */}
                    <button
                        onClick={handleStartGame}
                        disabled={players.length < 2}
                        className="w-full py-3 bg-secondary text-white font-bold text-lg rounded-xl shadow-lg transition disabled:bg-gray-400"
                    >
                        {players.length < 2 ? 'C·∫ßn 2 ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu' : `B·∫ÆT ƒê·∫¶U TR√í CH∆†I (${parseInt(maxRounds) || 15} V√ÅN)`}
                    </button>
                </div>
            );

            // Stage 1: Playing (ƒê√£ t·ªëi ∆∞u giao di·ªán)
            const renderPlaying = () => (
                <div className="p-4 sm:p-6">
                    <h2 className="text-xl sm:text-2xl font-bold text-primary mb-4 text-center">
                        V√ÅN {history.length + 1} / {parseInt(maxRounds) || 15}
                    </h2>
                    
                    {/* V√πng Ghi ƒêi·ªÉm (ƒê·∫£o v·ªã tr√≠) */}
                    <div className="mb-4 flex flex-col space-y-4">
                        
                        {isScoringMode && (
                            // Hi·ªán v√πng nh·∫≠p ƒëi·ªÉm ·ªü tr√™n n√∫t x√°c nh·∫≠n
                            <div className="p-4 bg-indigo-50 rounded-xl shadow border border-indigo-200 animate-fade-in order-1">
                                <h4 className="font-semibold text-primary mb-3">Nh·∫≠p ƒëi·ªÉm v√°n {history.length + 1}:</h4>
                                {playerScores.map(p => (
                                    <div key={p.id} className="flex items-center justify-between space-x-2 mb-3">
                                        {/* T√™n ng∆∞·ªùi ch∆°i: Chi·∫øm 50% */}
                                        <span className="w-1/2 text-gray-700 truncate font-medium text-lg">{p.name}:</span>
                                        {/* C·ª•m TƒÉng/Gi·∫£m: Chi·∫øm 50%, s√°t b√™n ph·∫£i */}
                                        <div className="grid grid-cols-3 w-1/2 gap-1">
                                            {/* N√∫t Gi·∫£m */}
                                            <button 
                                                onClick={() => handleScoreChange(p.id, (parseInt(roundScoreInputs[p.id]) || 0) - 1)}
                                                className="p-2 bg-danger text-white rounded-lg font-bold text-base"
                                            >
                                                -
                                            </button>
                                            {/* Input ƒêi·ªÉm: G·ªçn l·∫°i */}
                                            <input
                                                type="number"
                                                // Hi·ªÉn th·ªã '0' n·∫øu gi√° tr·ªã l√† s·ªë 0, n·∫øu l√† string r·ªóng (t·ª´ input) th√¨ ƒë·ªÉ r·ªóng
                                                value={roundScoreInputs[p.id] === 0 && roundScoreInputs[p.id] !== '' ? '0' : roundScoreInputs[p.id]}
                                                onChange={(e) => handleScoreChange(p.id, e.target.value)}
                                                // ƒê√£ ƒëi·ªÅu ch·ªânh padding (p-1) v√† font-size (text-xl) cho g·ªçn
                                                className="p-1 border border-gray-300 rounded-lg text-center font-mono text-xl"
                                                placeholder="0"
                                            />
                                            {/* N√∫t TƒÉng (ƒê√£ s·ª≠a layout) */}
                                            <button 
                                                onClick={() => handleScoreChange(p.id, (parseInt(roundScoreInputs[p.id]) || 0) + 1)}
                                                className="p-2 bg-secondary text-white rounded-lg font-bold text-base"
                                            >
                                                +
                                            </button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                        
                        {/* N√∫t Ghi/X√°c nh·∫≠n ƒëi·ªÉm (ƒê√£ ƒë·ªïi th·ª© t·ª±) */}
                         <button
                            onClick={handleNewScoreClick}
                            className={`w-full py-3 font-bold text-white rounded-xl shadow-lg transition duration-300 transform ${isScoringMode ? 'bg-warning animate-pulse-slow' : 'bg-primary'}`}
                        >
                            {isScoringMode ? 'X√ÅC NH·∫¨N GHI ƒêI·ªÇM V√ÅN N√ÄY' : 'GHI ƒêI·ªÇM V√ÅN M·ªöI'}
                        </button>
                    </div>
                    
                    
                    {/* C√°c n√∫t ch·ª©c nƒÉng */}
                    <div className="flex justify-between space-x-2 mb-4">
                         <button
                            onClick={handleUndo}
                            disabled={history.length === 0 || isScoringMode}
                            className="flex-1 py-2 bg-warning text-white font-semibold rounded-lg transition disabled:bg-gray-400 text-sm"
                        >
                            ‚Ü©Ô∏è Ho√†n T√°c
                        </button>
                        <button
                            onClick={handleSetRoundsClick}
                            disabled={isScoringMode}
                            className="flex-1 py-2 bg-blue-500 text-white font-semibold rounded-lg transition disabled:bg-gray-400 text-sm"
                        >
                            üîÅ Set V√°n
                        </button>
                        <button
                            onClick={() => setGameState('game_over')}
                            disabled={isScoringMode}
                            className="flex-1 py-2 bg-gray-600 text-white font-semibold rounded-lg transition disabled:bg-gray-400 text-sm"
                        >
                            üõë K·∫øt Th√∫c
                        </button>
                    </div>
                    
                    
                    {/* L·ªãch s·ª≠ ƒëi·ªÉm (ƒê√£ t·ªëi ∆∞u cu·ªôn ngang) */}
                    <div className="bg-white p-4 rounded-xl shadow-lg">
                        <button 
                            onClick={() => setShowHistory(prev => !prev)}
                            className="w-full text-left text-lg font-semibold text-gray-700 mb-2 p-2 rounded-lg transition flex justify-between items-center"
                        >
                            L·ªãch S·ª≠ ƒêi·ªÉm ({history.length} V√°n) {showHistory ? '‚ñ≤' : '‚ñº'}
                        </button>
                        {showHistory && (
                            <div className="overflow-x-auto mt-2 max-h-64">
                                <table className="min-w-full divide-y divide-gray-200">
                                    <thead className="bg-gray-50 sticky left-0 z-10">
                                        <tr>
                                            {/* C·ªôt T√™n Ng∆∞·ªùi Ch∆°i (Fixed/Sticky) */}
                                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase sticky left-0 bg-gray-50 shadow-sm">Ng∆∞·ªùi ch∆°i</th>
                                            {/* C·ªôt ƒêi·ªÉm c√°c V√°n (Cu·ªôn) */}
                                            {[...Array(history.length)].map((_, index) => (
                                                <th key={index} className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase min-w-[50px]">V√°n {history.length - index}</th>
                                            ))}
                                        </tr>
                                    </thead>
                                    <tbody className="bg-white divide-y divide-gray-200">
                                        {players.map(p => (
                                            <tr key={p.id}>
                                                {/* D·ªØ li·ªáu T√™n Ng∆∞·ªùi Ch∆°i (Fixed/Sticky) */}
                                                <td 
                                                    className="px-3 py-2 whitespace-nowrap text-sm font-medium text-gray-900 sticky left-0 bg-white shadow-sm truncate" 
                                                    title={p.name}
                                                >
                                                    {p.name}
                                                </td>
                                                {/* D·ªØ li·ªáu ƒêi·ªÉm c√°c V√°n (Cu·ªôn) - Hi·ªÉn th·ªã t·ª´ v√°n m·ªõi nh·∫•t v·ªÅ c≈© nh·∫•t */}
                                                {[...history].reverse().map(entry => {
                                                    const score = entry.scores[p.id] || 0;
                                                    const colorClass = score > 0 ? 'text-secondary font-bold' : (score < 0 ? 'text-danger' : 'text-gray-500');
                                                    return (
                                                        <td key={entry.round} className={`px-3 py-2 whitespace-nowrap text-sm text-center ${colorClass} min-w-[50px] font-mono`}>
                                                            {score > 0 ? `+${score}` : score}
                                                        </td>
                                                    );
                                                })}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </div>
                </div>
            );

            // Stage 2: Game Over (Kh√¥ng c·∫ßn thay ƒë·ªïi nhi·ªÅu)
            const renderGameOver = () => (
                <div className="p-6 text-center animate-bounce-in">
                    <h2 className="text-4xl font-extrabold text-danger mb-6">üéâ TR√í CH∆†I K·∫æT TH√öC! üéâ</h2>
                    <p className="text-xl font-medium text-gray-700 mb-8">T·ªïng s·ªë v√°n ƒë√£ ch∆°i: <span className="text-primary font-bold">{history.length}</span></p>

                    {/* B·∫£ng X·∫øp H·∫°ng */}
                    <div className="bg-white p-6 rounded-xl shadow-2xl mb-8">
                        <h3 className="text-2xl font-bold text-primary mb-4 border-b pb-2">üèÜ B·∫¢NG X·∫æP H·∫†NG</h3>
                        {playerScores.map((p, index) => (
                            <div 
                                key={p.id} 
                                className={`flex justify-between items-center py-3 px-4 my-2 rounded-lg transition transform duration-300 ${index === 0 ? 'bg-yellow-100 border-2 border-warning scale-105 shadow-lg' : 'bg-gray-50'}`}
                            >
                                <span className={`text-xl font-bold ${index === 0 ? 'text-warning' : 'text-gray-700'}`}>
                                    {index + 1}. {p.name}
                                </span>
                                <span className={`text-3xl font-extrabold ${p.totalScore >= 0 ? 'text-secondary' : 'text-danger'} font-mono`}>
                                    {p.totalScore}
                                </span>
                            </div>
                        ))}
                    </div>

                    {/* N√∫t Ch∆°i L·∫°i */}
                    <button
                        onClick={() => {
                            setGameState('setup');
                            setPlayers([]);
                            setHistory([]);
                            setIsScoringMode(false);
                            setRoundScoreInputs({});
                            setMaxRounds(15); // Reset max rounds to default
                            localStorage.clear(); // X√≥a to√†n b·ªô localStorage
                            // Note: We use window.location.reload() to fully reset the component state and localStorage
                            window.location.reload(); 
                        }}
                        className="w-full py-3 bg-secondary text-white font-bold text-xl rounded-xl shadow-lg transition"
                    >
                        CH∆†I L·∫†I
                    </button>
                </div>
            );
            
            // --- Logic Render Ch√≠nh ---

            return (
                <div className="min-h-screen bg-gray-50 flex justify-center">
                    <div className="w-full max-w-xl mx-auto bg-white shadow-xl rounded-2xl overflow-hidden my-0 sm:my-4">
                        <header className="bg-primary text-white p-3 text-center">
                            <h1 className="text-2xl font-extrabold">GHI ƒêI·ªÇM TR√í CH∆†I</h1>
                        </header>
                        
                        {gameState === 'setup' && renderSetup()}
                        {gameState === 'playing' && renderPlaying()}
                        {gameState === 'game_over' && renderGameOver()}
                    </div>

                    {/* Modal Popup */}
                    <Modal
                        title={modal.type === 'info' ? 'Th√¥ng b√°o' : modal.type === 'confirm_undo' ? 'X√°c nh·∫≠n Ho√†n t√°c' : 'Set l·∫°i S·ªë V√°n Ch∆°i'}
                        isOpen={modal.isOpen}
                        onClose={() => setModal({ isOpen: false, type: null, data: null })}
                        onConfirm={modal.type === 'confirm_undo' ? confirmUndo : 
                                   modal.type === 'reset_rounds' ? confirmResetRounds :
                                   () => setModal({ isOpen: false, type: null, data: null }) // D√†nh cho type 'info'
                                  }
                        confirmText={modal.type === 'info' ? 'ƒê√≥ng' : 'X√°c nh·∫≠n'}
                        showCancel={modal.type !== 'info'}
                        content={renderModalContent()}
                    />
                </div>
            );
        }

        // Render ·ª©ng d·ª•ng React v√†o DOM
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

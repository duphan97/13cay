<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ứng Dụng Ghi Điểm Trò Chơi</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#4f46e5', // Indigo 600
                        'secondary': '#10b981', // Emerald 500
                        'warning': '#f59e0b', // Amber 500
                        'danger': '#ef4444', // Red 500
                    },
                }
            }
        }
    </script>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        @keyframes bounce-in {
            0%, 20%, 40%, 60%, 80%, 100% {
                transition-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
            }
            0% { opacity: 0; transform: scale3d(.3, .3, .3); }
            40% { transform: scale3d(1.1, 1.1, 1.1); }
            80% { transform: scale3d(.97, .97, .97); }
            100% { opacity: 1; transform: scale3d(1, 1, 1); }
        }
        .animate-bounce-in {
            animation: bounce-in 0.8s;
        }
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fade-in 0.3s ease-out;
        }
        .animate-pulse-slow {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;
        const MAX_PLAYERS = 4;
        
        // Cấu hình đường dẫn cho âm thanh cục bộ
        const AUDIO_BASE_PATH = 'audio/';
        
        /* * DANH SÁCH FILE AUDIO CẦN CÓ TRONG THƯ MỤC 'audio/':
        * 1. Hệ thống: vanmoi.mp3, dacong.mp3, datru.mp3, colen.mp3, chiabuon.mp3, va.mp3, dathua.mp3
        * 2. Số điểm: 0.mp3, 1.mp3, 2.mp3, ... (cho các số điểm thường gặp)
        * 3. Tên người chơi: binhdang.mp3, dunghoang.mp3, dungnguyen.mp3, duphan.mp3, dongle.mp3, v.v.
        */

        // Danh sách tên người chơi có sẵn
        const PRESET_PLAYERS = ["Bình Đặng", "Dũng Hoàng", "Dũng Nguyễn", "Dự Phan", "Đông Lê"];
        const PRESET_ROUNDS = [15, 21, 31];

        // --- 1. Custom Hooks & Utilities ---

        // Hàm chuẩn hóa tên người chơi thành tên file không dấu, không khoảng trắng, chữ thường
        const normalizeName = (name) => {
            // Loại bỏ dấu tiếng Việt (NFD and combining marks regex)
            return name
                .normalize('NFD').replace(/[\u0300-\u036f]/g, "") 
                .toLowerCase()
                .replace(/\s+/g, ''); // Loại bỏ khoảng trắng
        };

        // Custom Hook: Xử lý Audio theo hàng đợi (Đảm bảo không bị chồng chéo VÀ TẢI TRƯỚC)
        const useAudioQueue = () => {
            // Hàng đợi lưu trữ các MẢNG CÁC ĐỐI TƯỢNG AUDIO đã được tải (preloaded Audio objects)
            const audioQueue = useRef([]); 
            const isPlaying = useRef(false); // Cờ trạng thái: Đang phát hay không?

            // Hàm tải trước và trả về một promise (hoặc một mảng các đối tượng Audio)
            const preloadAudioSequence = useCallback((soundNames) => {
                const audioObjects = soundNames.map(name => {
                    const fullPath = `${AUDIO_BASE_PATH}${name}.mp3`;
                    const audio = new Audio(fullPath);
                    audio.volume = 0.8;
                    return audio;
                });

                // Promise.all chờ tất cả các file load thành công
                const loadPromises = audioObjects.map(audio => new Promise((resolve, reject) => {
                    // Nếu đã sẵn sàng (cached/loaded), resolve ngay
                    if (audio.readyState >= 2) { // 2 = Have enough data
                        resolve();
                        return;
                    }
                    
                    // Sự kiện 'canplaythrough' đảm bảo file đã được tải đủ để phát mà không bị ngắt quãng
                    audio.addEventListener('canplaythrough', resolve, { once: true });
                    
                    // Xử lý lỗi tải file
                    audio.addEventListener('error', (e) => {
                        console.warn(`Lỗi tải file: ${audio.src}. Chuỗi phát này sẽ bị bỏ qua.`);
                        // Bất kỳ lỗi nào cũng làm hỏng toàn bộ chuỗi
                        reject(new Error(`Failed to load ${audio.src}`));
                    }, { once: true });
                    
                    // Bắt đầu tải
                    audio.load();
                }));

                return Promise.all(loadPromises)
                    .then(() => audioObjects) // Trả về mảng các đối tượng Audio đã được tải
                    .catch(error => {
                        // Nếu có lỗi, trả về mảng rỗng để báo hiệu bỏ qua chuỗi này
                        console.error('Toàn bộ chuỗi phát âm thanh này bị bỏ qua do lỗi tải file.', error.message);
                        return []; 
                    });

            }, []);

            const playNext = useCallback(() => {
                // Chỉ phát nếu còn file trong hàng đợi VÀ hiện tại KHÔNG có file nào đang phát
                if (audioQueue.current.length > 0 && !isPlaying.current) {
                    isPlaying.current = true;
                    // Lấy toàn bộ mảng các đối tượng Audio đã được tải ra khỏi hàng đợi
                    const currentSequence = audioQueue.current.shift(); 
                    let currentAudioIndex = 0;

                    // Hàm đệ quy phát lần lượt từng file trong chuỗi
                    const playSequence = () => {
                        if (currentAudioIndex >= currentSequence.length) {
                            // Kết thúc chuỗi, mở khóa và chuyển sang chuỗi tiếp theo
                            isPlaying.current = false; 
                            playNext(); 
                            return;
                        }

                        const audio = currentSequence[currentAudioIndex];
                        
                        // Đặt sự kiện onended trước khi play
                        audio.onended = () => {
                            currentAudioIndex++;
                            // Chơi liền mạch (delay 0ms), gọi playSequence() ngay
                            playSequence(); 
                        };

                        // Bắt đầu phát
                        audio.play().catch(e => {
                            console.warn("Autoplay was prevented or playback error:", audio.src, e);
                            // Nếu lỗi phát, chuyển sang file tiếp theo
                            currentAudioIndex++;
                            playSequence();
                        });
                    };

                    // Bắt đầu phát chuỗi
                    if (currentSequence.length > 0) {
                        playSequence();
                    } else {
                        // Nếu chuỗi rỗng (do lỗi tải), chuyển sang chuỗi tiếp theo ngay lập tức
                        isPlaying.current = false;
                        playNext();
                    }
                }
            }, []);

            // Thêm một hoặc nhiều TÊN file vào hàng đợi (sẽ được preload)
            const addToQueue = useCallback((soundNamesArray) => {
                // soundNamesArray là một mảng chứa TÊN file (vd: ['vanmoi'] hoặc ['dacong', '5', 'binhdang'])
                
                // 1. Tải trước và thêm vào hàng đợi
                const loadingPromise = preloadAudioSequence(soundNamesArray)
                    .then(preloadedAudioObjects => {
                        if (preloadedAudioObjects.length > 0) {
                            audioQueue.current.push(preloadedAudioObjects);
                        }
                    })
                    .finally(() => {
                        // 2. Bắt đầu chu trình phát (nếu chưa phát)
                        if (!isPlaying.current) {
                            playNext();
                        }
                    });

                return loadingPromise; // Trả về promise để theo dõi quá trình tải
            }, [playNext, preloadAudioSequence]);


            // Đối với logic đọc điểm (nhiều người chơi), ta cần một hàm gom các chuỗi lại:
            const addMultipleSequencesToQueue = useCallback((sequences) => {
                let initialPlayTriggered = false;
                
                // Tạo một mảng promises để chờ tất cả các chuỗi tải xong
                const allSequencesLoaded = sequences.map(soundNamesArray => {
                     return preloadAudioSequence(soundNamesArray)
                        .then(preloadedAudioObjects => {
                            if (preloadedAudioObjects.length > 0) {
                                audioQueue.current.push(preloadedAudioObjects);
                                // Kích hoạt phát lần đầu ngay sau khi chuỗi đầu tiên được tải
                                if (!isPlaying.current && !initialPlayTriggered) {
                                    initialPlayTriggered = true;
                                    playNext();
                                }
                            }
                        });
                });

                // Chờ tất cả promises hoàn thành trước khi gọi playNext() một lần cuối để đảm bảo hàng đợi không bị bỏ sót
                Promise.all(allSequencesLoaded).finally(() => {
                    if (!isPlaying.current) {
                        playNext();
                    }
                });

            }, [playNext, preloadAudioSequence]);


            return { 
                addToQueue: addToQueue, // Dùng cho các lệnh đơn lẻ (vd: 'vanmoi')
                addMultipleSequencesToQueue: addMultipleSequencesToQueue // Dùng cho logic đọc điểm (nhiều chuỗi liền nhau)
            };
        };


        // Custom Hook: Quản lý State với LocalStorage
        const useLocalStorageState = (key, defaultValue) => {
            const [state, setState] = useState(() => {
                const storedValue = localStorage.getItem(key);
                try {
                    return storedValue ? JSON.parse(storedValue) : defaultValue;
                } catch (e) {
                    console.error("Lỗi khi parse localStorage:", e);
                    return defaultValue;
                }
            });

            useEffect(() => {
                try {
                    localStorage.setItem(key, JSON.stringify(state));
                } catch (e) {
                    console.error("Lỗi khi lưu vào localStorage:", e);
                }
            }, [key, state]);

            return [state, setState];
        };

        // Hàm tạo ID duy nhất
        const generateId = () => Math.random().toString(36).substring(2, 9);
        
        // --- 2. Component Con: Modal (Thay thế alert/confirm) ---

        const Modal = ({ title, content, isOpen, onClose, onConfirm, confirmText = "Xác nhận", cancelText = "Hủy bỏ", showCancel = true }) => {
            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 animate-fade-in">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-sm animate-bounce-in">
                        <header className="px-4 py-3 bg-primary rounded-t-xl">
                            <h3 className="text-xl font-bold text-white">{title}</h3>
                        </header>
                        <div className="p-4">
                            {content}
                        </div>
                        <footer className="flex justify-end space-x-3 p-4 border-t border-gray-100">
                            {showCancel && (
                                <button
                                    onClick={onClose}
                                    className="px-4 py-2 text-sm font-semibold text-gray-700 bg-gray-200 rounded-lg transition"
                                >
                                    {cancelText}
                                </button>
                            )}
                            <button
                                onClick={onConfirm}
                                className="px-4 py-2 text-sm font-semibold text-white bg-secondary rounded-lg transition"
                            >
                                {confirmText}
                            </button>
                        </footer>
                    </div>
                </div>
            );
        };

        // --- 3. Component Chính: App ---

        function App() {
            // State chính của ứng dụng
            const [gameState, setGameState] = useLocalStorageState('gameState', 'setup'); // 'setup', 'playing', 'game_over'
            const [players, setPlayers] = useLocalStorageState('players', []);
            // maxRounds có thể là string ('') hoặc number
            const [maxRounds, setMaxRounds] = useLocalStorageState('maxRounds', 15); 
            const [history, setHistory] = useLocalStorageState('history', []);
            const [showHistory, setShowHistory] = useState(false);
            const [isScoringMode, setIsScoringMode] = useState(false);
            const [newPlayerName, setNewPlayerName] = useState('');
            const [roundScoreInputs, setRoundScoreInputs] = useLocalStorageState('roundScoreInputs', {}); // Giữ lại giá trị khi refresh
            const [modal, setModal] = useState({ isOpen: false, type: null, data: null });
            const [newMaxRoundsInput, setNewMaxRoundsInput] = useState(15);
            
            const { addToQueue, addMultipleSequencesToQueue } = useAudioQueue(); // Hook quản lý hàng đợi âm thanh

            // Tính toán tổng điểm và bảng xếp hạng
            const playerScores = useMemo(() => {
                const roundsLimit = parseInt(maxRounds) || 15; // Dùng maxRounds đã parse cho an toàn
                return players.map(p => {
                    const totalScore = history.reduce((sum, round) => sum + (round.scores[p.id] || 0), 0);
                    return { ...p, totalScore };
                }).sort((a, b) => b.totalScore - a.totalScore); // Sắp xếp từ cao xuống thấp
            }, [players, history, maxRounds]);

            // --- Logic Audio 4. Phát âm thanh đọc điểm (Đã tối ưu) ---
            const playScoreAudio = (currentRoundScores) => {
                // Tạo mảng chi tiết điểm, có điểm ván vừa ghi
                const scoreDetails = playerScores.map(p => ({
                    name: p.name,
                    score: currentRoundScores[p.id] || 0,
                    id: p.id
                }));
                
                // Sắp xếp theo điểm ván vừa ghi (cao -> thấp)
                scoreDetails.sort((a, b) => b.score - a.score);

                let allAudioSequences = [];
                
                scoreDetails.forEach(detail => {
                    const absScore = Math.abs(detail.score);
                    const nameFile = normalizeName(detail.name); // Tên người chơi chuẩn hóa
                    const scoreStr = absScore.toString(); // Số điểm (ví dụ: '5', '10')

                    let audioSequence = [];

                    if (detail.score > 0) {
                        // ĐIỂM DƯƠNG: 'dacong', [Absolute Score file], [Name file]
                        audioSequence = ['dacong', scoreStr, nameFile]; 
                    } else if (detail.score < 0) {
                        // ĐIỂM ÂM: 'datru', [Absolute Score file], [Name file], 'colen'
                        audioSequence = ['datru', scoreStr, nameFile, 'colen'];
                    } else {
                        // ĐIỂM BẰNG 0: [Name file], '0', 'colen'
                        audioSequence = [nameFile, '0', 'colen'];
                    }
                    
                    // Thêm chuỗi phát của người chơi này vào danh sách tổng
                    allAudioSequences.push(audioSequence);
                });
                
                // Gửi tất cả các chuỗi để được tải trước và phát liền mạch
                addMultipleSequencesToQueue(allAudioSequences);
            };

            // Logic Audio 6. Kết thúc trò chơi (Đã tối ưu)
            const playGameOverAudio = (sortedPlayers) => {
                if (sortedPlayers.length < 2) return;
                
                // Người ít điểm nhất là người cuối cùng trong mảng đã sắp xếp (thấp điểm)
                const lastPlayer = sortedPlayers[sortedPlayers.length - 1];
                const secondLastPlayer = sortedPlayers[sortedPlayers.length - 2];

                const lastPlayerName = normalizeName(lastPlayer.name);
                const secondLastPlayerName = normalizeName(secondLastPlayer.name);

                // Format: chiabuon.mp3 + Tên người 1 + va.mp3 + Tên người 2 + dathua.mp3
                const audioSequence = [
                    'chiabuon', 
                    lastPlayerName, 
                    'va', 
                    secondLastPlayerName, 
                    'dathua'
                ];
                
                // Sử dụng addToQueue cho lệnh đơn (dù nó là một chuỗi)
                addToQueue(audioSequence);
            };

            // --- 5. Lịch sử điểm và Tổng kết ván ---
            useEffect(() => {
                const roundsLimit = parseInt(maxRounds);
                if (gameState === 'playing' && history.length > 0 && roundsLimit > 0 && history.length >= roundsLimit) {
                    setGameState('game_over');
                    // Tính lại playerScores cuối cùng trước khi phát audio kết thúc
                    const finalPlayerScores = players.map(p => {
                        const totalScore = history.reduce((sum, round) => sum + (round.scores[p.id] || 0), 0);
                        return { ...p, totalScore };
                    }).sort((a, b) => b.totalScore - a.totalScore);
                    
                    playGameOverAudio(finalPlayerScores);
                }
            }, [history, maxRounds, gameState, players]);
            
            // Khởi tạo/Cập nhật input scores khi players thay đổi (sau khi load state từ localStorage)
            useEffect(() => {
                 if (players.length > 0 && gameState === 'playing' && Object.keys(roundScoreInputs).length === 0) {
                    const initialInputs = players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                    setRoundScoreInputs(initialInputs);
                }
            }, [players, gameState, roundScoreInputs]);


            // --- 7. Hoàn tác (Undo) ---
            const handleUndo = () => {
                if (history.length === 0) return;

                setModal({
                    isOpen: true,
                    type: 'confirm_undo',
                    data: { message: `Bạn có chắc chắn muốn hoàn tác Ván ${history.length} không?` }
                });
            };

            const confirmUndo = () => {
                setHistory(prev => prev.slice(0, -1)); // Xóa ván cuối cùng
                setGameState('playing');
                setIsScoringMode(false);
                setRoundScoreInputs({});
                setModal({ isOpen: false, type: null, data: null });
            };


            // --- Xử lý Stage: Setup (Giai đoạn I) ---

            const handlePlayerToggle = (player) => {
                const newPlayers = players.find(p => p.id === player.id) 
                    ? players.filter(p => p.id !== player.id)
                    : [...players, player];
                
                if (newPlayers.length > MAX_PLAYERS) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Thông báo', message: `Số lượng người chơi tối đa là ${MAX_PLAYERS}.` }
                    });
                    return;
                }
                setPlayers(newPlayers);
            };

            const handleAddNewPlayer = () => {
                if (newPlayerName && players.length < MAX_PLAYERS) {
                    // Kiểm tra trùng tên (Không bắt buộc theo yêu cầu, nhưng nên có)
                    if (players.some(p => p.name.toLowerCase() === newPlayerName.trim().toLowerCase())) {
                         setModal({
                            isOpen: true,
                            type: 'info',
                            data: { title: 'Thông báo', message: `Người chơi '${newPlayerName}' đã tồn tại.` }
                        });
                        return;
                    }
                    
                    const normalizedName = normalizeName(newPlayerName);
                    // Dùng tên chuẩn hóa làm ID nếu chưa tồn tại
                    const newPlayer = { id: normalizedName + generateId(), name: newPlayerName.trim() }; // Thêm ID ngẫu nhiên để tránh trùng với PRESET
                    setPlayers([...players, newPlayer]);
                    setNewPlayerName('');
                } else if (players.length >= MAX_PLAYERS) {
                     setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Thông báo', message: `Số lượng người chơi tối đa là ${MAX_PLAYERS}.` }
                    });
                }
            };
            
            const handleStartGame = () => {
                if (players.length < 2) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Lỗi', message: 'Cần tối thiểu 2 người chơi để bắt đầu trò chơi.' }
                    });
                    return;
                }
                
                // Logic xử lý khi maxRounds là string (khi người dùng xóa input)
                const finalMaxRounds = parseInt(maxRounds);
                if (isNaN(finalMaxRounds) || finalMaxRounds < 1) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Lỗi', message: 'Số ván chơi phải là một số nguyên dương hợp lệ (tối thiểu 1).' }
                    });
                    setMaxRounds(15); // Reset về mặc định
                    return;
                }

                setMaxRounds(finalMaxRounds); // Đảm bảo state maxRounds là number
                setGameState('playing');
                // Khởi tạo các input điểm ván = 0 (dựa trên players mới)
                const initialInputs = players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                setRoundScoreInputs(initialInputs);
            };


            // --- Xử lý Stage: Playing (Giai đoạn II) ---

            // 3. Nút “Ghi điểm ván mới”
            const handleNewScoreClick = () => {
                if (!isScoringMode) {
                    addToQueue(['vanmoi']); // CHỈ PHÁT LẦN 1
                    setIsScoringMode(true);
                    // Reset input scores to 0 when entering scoring mode
                    const initialInputs = playerScores.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                    setRoundScoreInputs(initialInputs);
                } else {
                    // Xác nhận ghi điểm
                    handleConfirmScore();
                }
            };

            const handleScoreChange = (playerId, value) => {
                const numValue = value === '' ? '' : parseInt(value);
                // Giữ lại giá trị string rỗng nếu user xóa hết
                setRoundScoreInputs(prev => ({ ...prev, [playerId]: isNaN(numValue) ? value : numValue }));
            };

            const handleConfirmScore = () => {
                const newRoundScores = {};

                // Chuẩn hóa điểm
                playerScores.forEach(p => {
                    const score = roundScoreInputs[p.id];
                    // Nếu giá trị là '' (string rỗng) hoặc null, NaN thì gán 0
                    if (score === '' || score === null || isNaN(score)) {
                        newRoundScores[p.id] = 0; 
                    } else {
                        newRoundScores[p.id] = parseInt(score); // Đảm bảo là số nguyên
                    }
                });

                // Ghi kết quả vào lịch sử
                const newHistoryEntry = {
                    round: history.length + 1,
                    scores: newRoundScores,
                    timestamp: new Date().toISOString()
                };
                setHistory(prev => [...prev, newHistoryEntry]);

                // Phát âm thanh theo logic mới
                playScoreAudio(newRoundScores);

                // Reset trạng thái
                setIsScoringMode(false);
                setRoundScoreInputs({});
            };
            
            // 8. Set lại số ván chơi
            const handleSetRoundsClick = () => {
                 setModal({
                    isOpen: true,
                    type: 'reset_rounds',
                    data: { currentMax: parseInt(maxRounds) || 15, playedRounds: history.length }
                });
                setNewMaxRoundsInput(parseInt(maxRounds) || 15);
            };

            const confirmResetRounds = () => {
                const newMax = parseInt(newMaxRoundsInput);
                if (isNaN(newMax) || newMax <= 0) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Lỗi', message: 'Số ván mới phải là một số nguyên dương hợp lệ.' }
                    });
                    return;
                }
                if (newMax < history.length) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Lỗi', message: `Số ván mới (${newMax}) không được nhỏ hơn số ván đã chơi (${history.length}).` }
                    });
                    return;
                }
                setMaxRounds(newMax);
                setModal({ isOpen: false, type: null, data: null });
                if (history.length >= newMax) {
                    setGameState('game_over');
                    
                    // Tính lại playerScores cuối cùng trước khi phát audio kết thúc
                    const finalPlayerScores = players.map(p => {
                        const totalScore = history.reduce((sum, round) => sum + (round.scores[p.id] || 0), 0);
                        return { ...p, totalScore };
                    }).sort((a, b) => b.totalScore - a.totalScore);
                    
                    playGameOverAudio(finalPlayerScores);
                }
            };

            const renderModalContent = () => {
                switch (modal.type) {
                    case 'info':
                        return <div><p className="text-gray-700">{modal.data.message}</p></div>;
                    case 'confirm_undo':
                        return <div><p className="text-gray-700">{modal.data.message}</p></div>;
                    case 'reset_rounds':
                        return (
                            <div>
                                <p className="text-gray-700 mb-4">
                                    Ván đã chơi: <span className="font-bold text-primary">{modal.data.playedRounds}</span>.
                                    Số ván tối thiểu phải là <span className="font-bold text-primary">{modal.data.playedRounds}</span>.
                                </p>
                                <label className="block text-sm font-medium text-gray-700">Nhập số ván mới:</label>
                                <input
                                    type="number"
                                    min={modal.data.playedRounds}
                                    value={newMaxRoundsInput}
                                    onChange={(e) => setNewMaxRoundsInput(e.target.value)}
                                    className="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:ring-primary focus:border-primary"
                                />
                            </div>
                        );
                    default:
                        return null;
                }
            };

            // --- Render các Stage ---
            
            // Stage 0: Setup (Đã tối ưu giao diện)
            const renderSetup = () => (
                <div className="p-4 sm:p-6 pb-2">
                    <h2 className="text-xl font-bold text-primary mb-4 text-center">⚙️ Cấu Hình Trò Chơi</h2>

                    {/* Chọn Số Ván (Cùng hàng) */}
                    <div className="mb-4 p-3 bg-white rounded-lg shadow-sm border border-gray-200">
                        <h3 className="text-md font-semibold mb-2 text-gray-700">1. Chọn Số Ván Chơi (Hiện tại: {parseInt(maxRounds) || 15})</h3>
                        <div className="flex flex-wrap gap-2 mb-2">
                            {PRESET_ROUNDS.map(r => (
                                <button
                                    key={r}
                                    onClick={() => setMaxRounds(r)}
                                    className={`px-3 py-1 text-sm font-medium rounded-full transition ${parseInt(maxRounds) === r ? 'bg-primary text-white shadow-md' : 'bg-gray-200 text-gray-700'}`}
                                >
                                    {r} Ván
                                </button>
                            ))}
                        </div>
                        <input
                            type="number"
                            min="1"
                            value={maxRounds} // Có thể là string '' hoặc number
                            onChange={(e) => setMaxRounds(e.target.value)} // Chấp nhận string rỗng để user có thể xóa
                            onBlur={(e) => {
                                const val = parseInt(e.target.value);
                                if (isNaN(val) || val < 1) {
                                    setMaxRounds(1); // Set minimum to 1 if empty or invalid on blur
                                } else {
                                     setMaxRounds(val); // Ensure it's stored as a number on blur
                                }
                            }}
                            className="w-full p-2 border border-gray-300 rounded-lg text-sm mt-1 focus:ring-secondary focus:border-secondary"
                        />
                    </div>
                    
                    {/* Chọn Người Chơi */}
                    <div className="mb-4 p-3 bg-white rounded-lg shadow-sm border border-gray-200">
                        <h3 className="text-md font-semibold mb-2 text-gray-700">2. Chọn Người Chơi</h3>
                        
                        {/* Danh sách chọn sẵn */}
                        <div className="flex flex-wrap gap-2 border-b pb-3 mb-3">
                            {PRESET_PLAYERS.map(name => {
                                // Sử dụng tên chuẩn hóa làm ID
                                const id = normalizeName(name);
                                // Tạo ID duy nhất cho người chơi preset
                                const player = { id: id, name: name }; 
                                const isSelected = players.some(p => p.id === id);
                                return (
                                    <button
                                        key={name}
                                        onClick={() => handlePlayerToggle(player)}
                                        className={`px-3 py-1 text-sm rounded-full transition ${isSelected ? 'bg-secondary text-white font-semibold shadow-sm' : 'bg-gray-100 text-gray-600'} disabled:opacity-50`}
                                        disabled={!isSelected && players.length >= MAX_PLAYERS}
                                    >
                                        {name} {isSelected ? '✅' : ''}
                                    </button>
                                );
                            })}
                        </div>

                        {/* Thêm người chơi mới */}
                        <div className="flex space-x-2">
                            <input
                                type="text"
                                value={newPlayerName}
                                onChange={(e) => setNewPlayerName(e.target.value)}
                                placeholder="Tên người chơi mới..."
                                className="flex-grow p-2 text-sm border border-gray-300 rounded-lg focus:ring-primary focus:border-primary"
                                disabled={players.length >= MAX_PLAYERS}
                            />
                            <button
                                onClick={handleAddNewPlayer}
                                className="p-2 bg-primary text-white rounded-lg font-semibold text-sm transition disabled:bg-gray-400"
                                disabled={!newPlayerName.trim() || players.length >= MAX_PLAYERS}
                            >
                                Thêm
                            </button>
                        </div>
                        
                    </div>

                    {/* Danh sách người chơi đã chọn */}
                    <div className="mb-4 p-3 bg-indigo-50 rounded-lg border border-indigo-200">
                        <h3 className="text-md font-semibold text-primary mb-2">Người chơi đã chọn ({players.length}/{MAX_PLAYERS}):</h3>
                        <div className="flex flex-wrap gap-2">
                            {players.map(p => (
                                <span key={p.id} className="bg-primary text-white text-xs px-3 py-1 rounded-full flex items-center">
                                    {p.name}
                                    <button 
                                        onClick={() => handlePlayerToggle(p)}
                                        className="ml-2 text-white/80 font-bold text-xs"
                                    >
                                        &times;
                                    </button>
                                </span>
                            ))}
                        </div>
                        {players.length === 0 && <p className="text-sm text-gray-500 italic mt-2">Chưa có người chơi nào được chọn.</p>}
                    </div>

                    {/* Nút Bắt đầu */}
                    <button
                        onClick={handleStartGame}
                        disabled={players.length < 2}
                        className="w-full py-3 bg-secondary text-white font-bold text-lg rounded-xl shadow-lg transition disabled:bg-gray-400"
                    >
                        {players.length < 2 ? 'Cần 2 người chơi để bắt đầu' : `BẮT ĐẦU TRÒ CHƠI (${parseInt(maxRounds) || 15} VÁN)`}
                    </button>
                </div>
            );

            // Stage 1: Playing (Đã tối ưu giao diện)
            const renderPlaying = () => (
                <div className="p-4 sm:p-6">
                    <h2 className="text-xl sm:text-2xl font-bold text-primary mb-4 text-center">
                        VÁN {history.length + 1} / {parseInt(maxRounds) || 15}
                    </h2>
                    
                    {/* Vùng Ghi Điểm (Đảo vị trí) */}
                    <div className="mb-4 flex flex-col space-y-4">
                        
                        {isScoringMode && (
                            // Hiện vùng nhập điểm ở trên nút xác nhận
                            <div className="p-4 bg-indigo-50 rounded-xl shadow border border-indigo-200 animate-fade-in order-1">
                                <h4 className="font-semibold text-primary mb-3">Nhập điểm ván {history.length + 1}:</h4>
                                {playerScores.map(p => (
                                    <div key={p.id} className="flex items-center justify-between space-x-2 mb-3">
                                        {/* Tên người chơi: Chiếm 50% */}
                                        <span className="w-1/2 text-gray-700 truncate font-medium text-lg">{p.name}:</span>
                                        {/* Cụm Tăng/Giảm: Chiếm 50%, sát bên phải */}
                                        <div className="grid grid-cols-3 w-1/2 gap-1">
                                            {/* Nút Giảm */}
                                            <button 
                                                onClick={() => handleScoreChange(p.id, (parseInt(roundScoreInputs[p.id]) || 0) - 1)}
                                                className="p-2 bg-danger text-white rounded-lg font-bold text-base"
                                            >
                                                -
                                            </button>
                                            {/* Input Điểm: Gọn lại */}
                                            <input
                                                type="number"
                                                // Hiển thị '0' nếu giá trị là số 0, nếu là string rỗng (từ input) thì để rỗng
                                                value={roundScoreInputs[p.id] === 0 && roundScoreInputs[p.id] !== '' ? '0' : roundScoreInputs[p.id]}
                                                onChange={(e) => handleScoreChange(p.id, e.target.value)}
                                                // Đã điều chỉnh padding (p-1) và font-size (text-xl) cho gọn
                                                className="p-1 border border-gray-300 rounded-lg text-center font-mono text-xl"
                                                placeholder="0"
                                            />
                                            {/* Nút Tăng (Đã sửa layout) */}
                                            <button 
                                                onClick={() => handleScoreChange(p.id, (parseInt(roundScoreInputs[p.id]) || 0) + 1)}
                                                className="p-2 bg-secondary text-white rounded-lg font-bold text-base"
                                            >
                                                +
                                            </button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                        
                        {/* Nút Ghi/Xác nhận điểm (Đã đổi thứ tự) */}
                         <button
                            onClick={handleNewScoreClick}
                            className={`w-full py-3 font-bold text-white rounded-xl shadow-lg transition duration-300 transform ${isScoringMode ? 'bg-warning animate-pulse-slow' : 'bg-primary'}`}
                        >
                            {isScoringMode ? 'XÁC NHẬN GHI ĐIỂM VÁN NÀY' : 'GHI ĐIỂM VÁN MỚI'}
                        </button>
                    </div>
                    
                    
                    {/* Các nút chức năng */}
                    <div className="flex justify-between space-x-2 mb-4">
                         <button
                            onClick={handleUndo}
                            disabled={history.length === 0 || isScoringMode}
                            className="flex-1 py-2 bg-warning text-white font-semibold rounded-lg transition disabled:bg-gray-400 text-sm"
                        >
                            ↩️ Hoàn Tác
                        </button>
                        <button
                            onClick={handleSetRoundsClick}
                            disabled={isScoringMode}
                            className="flex-1 py-2 bg-blue-500 text-white font-semibold rounded-lg transition disabled:bg-gray-400 text-sm"
                        >
                            🔁 Set Ván
                        </button>
                        <button
                            onClick={() => setGameState('game_over')}
                            disabled={isScoringMode}
                            className="flex-1 py-2 bg-gray-600 text-white font-semibold rounded-lg transition disabled:bg-gray-400 text-sm"
                        >
                            🛑 Kết Thúc
                        </button>
                    </div>
                    
                    
                    {/* Lịch sử điểm (Đã tối ưu cuộn ngang) */}
                    <div className="bg-white p-4 rounded-xl shadow-lg">
                        <button 
                            onClick={() => setShowHistory(prev => !prev)}
                            className="w-full text-left text-lg font-semibold text-gray-700 mb-2 p-2 rounded-lg transition flex justify-between items-center"
                        >
                            Lịch Sử Điểm ({history.length} Ván) {showHistory ? '▲' : '▼'}
                        </button>
                        {showHistory && (
                            <div className="overflow-x-auto mt-2 max-h-64">
                                <table className="min-w-full divide-y divide-gray-200">
                                    <thead className="bg-gray-50 sticky left-0 z-10">
                                        <tr>
                                            {/* Cột Tên Người Chơi (Fixed/Sticky) */}
                                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase sticky left-0 bg-gray-50 shadow-sm">Người chơi</th>
                                            {/* Cột Điểm các Ván (Cuộn) */}
                                            {[...Array(history.length)].map((_, index) => (
                                                <th key={index} className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase min-w-[50px]">Ván {history.length - index}</th>
                                            ))}
                                        </tr>
                                    </thead>
                                    <tbody className="bg-white divide-y divide-gray-200">
                                        {players.map(p => (
                                            <tr key={p.id}>
                                                {/* Dữ liệu Tên Người Chơi (Fixed/Sticky) */}
                                                <td 
                                                    className="px-3 py-2 whitespace-nowrap text-sm font-medium text-gray-900 sticky left-0 bg-white shadow-sm truncate" 
                                                    title={p.name}
                                                >
                                                    {p.name}
                                                </td>
                                                {/* Dữ liệu Điểm các Ván (Cuộn) - Hiển thị từ ván mới nhất về cũ nhất */}
                                                {[...history].reverse().map(entry => {
                                                    const score = entry.scores[p.id] || 0;
                                                    const colorClass = score > 0 ? 'text-secondary font-bold' : (score < 0 ? 'text-danger' : 'text-gray-500');
                                                    return (
                                                        <td key={entry.round} className={`px-3 py-2 whitespace-nowrap text-sm text-center ${colorClass} min-w-[50px] font-mono`}>
                                                            {score > 0 ? `+${score}` : score}
                                                        </td>
                                                    );
                                                })}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </div>
                </div>
            );

            // Stage 2: Game Over (Không cần thay đổi nhiều)
            const renderGameOver = () => (
                <div className="p-6 text-center animate-bounce-in">
                    <h2 className="text-4xl font-extrabold text-danger mb-6">🎉 TRÒ CHƠI KẾT THÚC! 🎉</h2>
                    <p className="text-xl font-medium text-gray-700 mb-8">Tổng số ván đã chơi: <span className="text-primary font-bold">{history.length}</span></p>

                    {/* Bảng Xếp Hạng */}
                    <div className="bg-white p-6 rounded-xl shadow-2xl mb-8">
                        <h3 className="text-2xl font-bold text-primary mb-4 border-b pb-2">🏆 BẢNG XẾP HẠNG</h3>
                        {playerScores.map((p, index) => (
                            <div 
                                key={p.id} 
                                className={`flex justify-between items-center py-3 px-4 my-2 rounded-lg transition transform duration-300 ${index === 0 ? 'bg-yellow-100 border-2 border-warning scale-105 shadow-lg' : 'bg-gray-50'}`}
                            >
                                <span className={`text-xl font-bold ${index === 0 ? 'text-warning' : 'text-gray-700'}`}>
                                    {index + 1}. {p.name}
                                </span>
                                <span className={`text-3xl font-extrabold ${p.totalScore >= 0 ? 'text-secondary' : 'text-danger'} font-mono`}>
                                    {p.totalScore}
                                </span>
                            </div>
                        ))}
                    </div>

                    {/* Nút Chơi Lại */}
                    <button
                        onClick={() => {
                            setGameState('setup');
                            setPlayers([]);
                            setHistory([]);
                            setIsScoringMode(false);
                            setRoundScoreInputs({});
                            setMaxRounds(15); // Reset max rounds to default
                            localStorage.clear(); // Xóa toàn bộ localStorage
                            // Note: We use window.location.reload() to fully reset the component state and localStorage
                            window.location.reload(); 
                        }}
                        className="w-full py-3 bg-secondary text-white font-bold text-xl rounded-xl shadow-lg transition"
                    >
                        CHƠI LẠI
                    </button>
                </div>
            );
            
            // --- Logic Render Chính ---

            return (
                <div className="min-h-screen bg-gray-50 flex justify-center">
                    <div className="w-full max-w-xl mx-auto bg-white shadow-xl rounded-2xl overflow-hidden my-0 sm:my-4">
                        <header className="bg-primary text-white p-3 text-center">
                            <h1 className="text-2xl font-extrabold">GHI ĐIỂM TRÒ CHƠI</h1>
                        </header>
                        
                        {gameState === 'setup' && renderSetup()}
                        {gameState === 'playing' && renderPlaying()}
                        {gameState === 'game_over' && renderGameOver()}
                    </div>

                    {/* Modal Popup */}
                    <Modal
                        title={modal.type === 'info' ? 'Thông báo' : modal.type === 'confirm_undo' ? 'Xác nhận Hoàn tác' : 'Set lại Số Ván Chơi'}
                        isOpen={modal.isOpen}
                        onClose={() => setModal({ isOpen: false, type: null, data: null })}
                        onConfirm={modal.type === 'confirm_undo' ? confirmUndo : 
                                   modal.type === 'reset_rounds' ? confirmResetRounds :
                                   () => setModal({ isOpen: false, type: null, data: null }) // Dành cho type 'info'
                                  }
                        confirmText={modal.type === 'info' ? 'Đóng' : 'Xác nhận'}
                        showCancel={modal.type !== 'info'}
                        content={renderModalContent()}
                    />
                </div>
            );
        }

        // Render ứng dụng React vào DOM
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

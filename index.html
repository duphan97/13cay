<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ứng Dụng Ghi Điểm Trò Chơi</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#4f46e5', // Indigo 600
                        'secondary': '#10b981', // Emerald 500
                        'warning': '#f59e0b', // Amber 500
                        'danger': '#ef4444', // Red 500
                    },
                }
            }
        }
    </script>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        @keyframes bounce-in {
            0%, 20%, 40%, 60%, 80%, 100% {
                transition-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
            }
            0% { opacity: 0; transform: scale3d(.3, .3, .3); }
            40% { transform: scale3d(1.1, 1.1, 1.1); }
            80% { transform: scale3d(.97, .97, .97); }
            100% { opacity: 1; transform: scale3d(1, 1, 1); }
        }
        .animate-bounce-in {
            animation: bounce-in 0.8s;
        }
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fade-in 0.3s ease-out;
        }
        .animate-pulse-slow {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;
        const MAX_PLAYERS = 4;
        
        // Cấu hình đường dẫn cho âm thanh cục bộ
        const AUDIO_BASE_PATH = 'audio/';
        
        /* * DANH SÁCH FILE AUDIO CẦN CÓ TRONG THƯ MỤC 'audio/':
        * 1. Hệ thống: vanmoi.mp3, chiabuon.mp3, va.mp3, dathua.mp3, gameover.mp3
        * Cảnh báo ván cuối: 3left.mp3, 2left.mp3, 1left.mp3
        * 2. Số điểm: -10.mp3, -9.mp3, ..., 0.mp3, ..., 10.mp3 (Phạm vi đọc điểm phổ biến)
        * 3. Tên người chơi: binhdang.mp3, dunghoang.mp3, dungnguyen.mp3, v.v.
        */

        // Danh sách tên người chơi có sẵn (ĐÃ SẮP XẾP)
        const PRESET_PLAYERS = [
            "Bình Đặng", 
            "Dũng Hoàng", 
            "Dũng Nguyễn", 
            "Định Ngô", 
            "Đông Lê", 
            "Khánh Đỗ", 
            "Minh Anh", 
            "Nhân Trần", 
            "Quý Huỳnh", 
            "Trúc Trần"
        ];
        const PRESET_ROUNDS = [15, 21, 31];

        // --- 1. Custom Hooks & Utilities ---

        // Hàm chuẩn hóa tên người chơi thành tên file không dấu, không khoảng trắng, chữ thường
        const normalizeName = (name) => {
            return name
                .toLowerCase()
                .normalize("NFD")
                .replace(/[\u0300-\u036f]/g, "") // bỏ dấu
                .replace(/đ/g, 'd')             // đổi đ -> d
                .replace(/\s+/g, '');           // bỏ khoảng trắng
        };

        // Custom Hook: Xử lý Audio theo hàng đợi (Đảm bảo không bị chồng chéo VÀ TẢI TRƯỚC)
        const useAudioQueue = () => {
            // Hàng đợi lưu trữ các MẢNG CÁC ĐỐI TƯỢNG AUDIO đã được tải (preloaded Audio objects)
            const audioQueue = useRef([]); 
            const isPlaying = useRef(false); // Cờ trạng thái: Đang phát hay không?

            const preloadAudioSequence = useCallback((soundNames) => {
                
                const loadAudioWithRetry = (name, maxRetries = 3) => {
                    // Kiểm tra nếu tên file rỗng (xảy ra khi score là 0 và user không có file "0.mp3")
                    if (!name || name === '') {
                        return Promise.resolve(null); // Trả về null để bỏ qua file này
                    }
                    
                    const fullPath = `${AUDIO_BASE_PATH}${name}.mp3`;
                    const audio = new Audio(fullPath);
                    audio.volume = 0.8;
                    let attempts = 0;

                    return new Promise((resolve, reject) => {
                        const tryLoad = () => {
                            attempts++;
                            
                            if (audio.readyState >= 2) { 
                                resolve(audio);
                                return;
                            }
                            
                            const handleSuccess = () => {
                                audio.removeEventListener('error', handleError); 
                                resolve(audio);
                            };
                            
                            const handleError = (e) => {
                                audio.removeEventListener('canplaythrough', handleSuccess);
                                audio.removeEventListener('error', handleError); 
                                
                                if (attempts < maxRetries) {
                                    setTimeout(tryLoad, 500); 
                                } else {
                                    console.error(`[LỖI TẢI FILE] Thất bại sau ${maxRetries} lần thử cho: ${audio.src}. Bỏ qua chuỗi âm thanh này.`);
                                    reject(new Error(`Failed to load ${audio.src} after ${maxRetries} attempts.`));
                                }
                            };

                            audio.addEventListener('canplaythrough', handleSuccess, { once: true });
                            audio.addEventListener('error', handleError, { once: true });
                            
                            audio.load();
                        };
                        
                        tryLoad();
                    });
                };

                // Tải tất cả các file, lọc bỏ các file không tải được (reject) hoặc là null (file rỗng)
                const loadPromises = soundNames.map(name => loadAudioWithRetry(name).catch(e => {
                    console.warn(`Tải file "${name}.mp3" thất bại, sẽ bỏ qua.`);
                    return null; // Đánh dấu là null để lọc
                }));


                return Promise.all(loadPromises)
                    .then(audioObjects => audioObjects.filter(obj => obj !== null)) // Chỉ trả về các đối tượng Audio hợp lệ
                    .catch(error => {
                        console.warn('Toàn bộ chuỗi phát âm thanh này đã bị bỏ qua do lỗi tải file đã được ghi nhận ở trên.');
                        return []; 
                    });

            }, []);

            const playNext = useCallback(() => {
                if (audioQueue.current.length > 0 && !isPlaying.current) {
                    isPlaying.current = true;
                    const currentSequence = audioQueue.current.shift(); 
                    let currentAudioIndex = 0;

                    const playSequence = () => {
                        if (currentAudioIndex >= currentSequence.length) {
                            isPlaying.current = false; 
                            playNext(); 
                            return;
                        }

                        const audio = currentSequence[currentAudioIndex];
                        
                        audio.onended = () => {
                            currentAudioIndex++;
                            playSequence(); 
                        };

                        audio.play().catch(e => {
                            console.warn("Autoplay was prevented or playback error:", audio.src, e);
                            currentAudioIndex++;
                            playSequence();
                        });
                    };

                    if (currentSequence.length > 0) {
                        playSequence();
                    } else {
                        isPlaying.current = false;
                        playNext();
                    }
                }
            }, []);

            const addToQueue = useCallback((soundNamesArray) => {
                const loadingPromise = preloadAudioSequence(soundNamesArray)
                    .then(preloadedAudioObjects => {
                        if (preloadedAudioObjects.length > 0) {
                            audioQueue.current.push(preloadedAudioObjects);
                        }
                    })
                    .finally(() => {
                        if (!isPlaying.current) {
                            playNext();
                        }
                    });

                return loadingPromise; 
            }, [playNext, preloadAudioSequence]);


            const addMultipleSequencesToQueue = useCallback((sequences) => {
                let initialPlayTriggered = false;
                
                const allSequencesLoaded = sequences.map(soundNamesArray => {
                     return preloadAudioSequence(soundNamesArray)
                        .then(preloadedAudioObjects => {
                            if (preloadedAudioObjects.length > 0) {
                                audioQueue.current.push(preloadedAudioObjects);
                                if (!isPlaying.current && !initialPlayTriggered) {
                                    initialPlayTriggered = true;
                                    playNext();
                                }
                            }
                        });
                });

                Promise.all(allSequencesLoaded).finally(() => {
                    if (!isPlaying.current) {
                        playNext();
                    }
                });

            }, [playNext, preloadAudioSequence]);


            return { 
                addToQueue: addToQueue,
                addMultipleSequencesToQueue: addMultipleSequencesToQueue
            };
        };


        // Custom Hook: Quản lý State với LocalStorage
        const useLocalStorageState = (key, defaultValue) => {
            const [state, setState] = useState(() => {
                const storedValue = localStorage.getItem(key);
                try {
                    return storedValue ? JSON.parse(storedValue) : defaultValue;
                } catch (e) {
                    console.error("Lỗi khi parse localStorage:", e);
                    return defaultValue;
                }
            });

            useEffect(() => {
                try {
                    localStorage.setItem(key, JSON.stringify(state));
                } catch (e) {
                    console.error("Lỗi khi lưu vào localStorage:", e);
                }
            }, [key, state]);

            return [state, setState];
        };

        // Hàm tạo ID duy nhất
        const generateId = () => Math.random().toString(36).substring(2, 9);
        
        // --- 2. Component Con: Modal (Thay thế alert/confirm) ---

        const Modal = ({ title, content, isOpen, onClose, onConfirm, confirmText = "Xác nhận", cancelText = "Hủy bỏ", showCancel = true }) => {
            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 animate-fade-in">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-sm animate-bounce-in">
                        <header className="px-4 py-3 bg-primary rounded-t-xl">
                            <h3 className="text-xl font-bold text-white">{title}</h3>
                        </header>
                        <div className="p-4">
                            {content}
                        </div>
                        <footer className="flex justify-end space-x-3 p-4 border-t border-gray-100">
                            {showCancel && (
                                <button
                                    onClick={onClose}
                                    className="px-4 py-2 text-sm font-semibold text-gray-700 bg-gray-200 rounded-lg transition"
                                >
                                    {cancelText}
                                </button>
                            )}
                            <button
                                onClick={onConfirm}
                                className="px-4 py-2 text-sm font-semibold text-white bg-secondary rounded-lg transition"
                            >
                                {confirmText}
                            </button>
                        </footer>
                    </div>
                </div>
            );
        };

        // --- 3. Component Chính: App ---

        function App() {
            // State chính của ứng dụng
            const [gameState, setGameState] = useLocalStorageState('gameState', 'setup'); // 'setup', 'playing', 'game_over'
            const [players, setPlayers] = useLocalStorageState('players', []);
            // maxRounds có thể là string ('') hoặc number
            const [maxRounds, setMaxRounds] = useLocalStorageState('maxRounds', 15); 
            const [history, setHistory] = useLocalStorageState('history', []);
            const [showHistory, setShowHistory] = useState(false); // cho màn hình Playing
            const [showGameOverHistory, setShowGameOverHistory] = useState(false); // cho màn hình Game Over
            const [isScoringMode, setIsScoringMode] = useState(false);
            const [newPlayerName, setNewPlayerName] = useState('');
            const [roundScoreInputs, setRoundScoreInputs] = useLocalStorageState('roundScoreInputs', {}); // Giữ lại giá trị khi refresh
            const [modal, setModal] = useState({ isOpen: false, type: null, data: null });
            const [newMaxRoundsInput, setNewMaxRoundsInput] = useState(15);
            
            const { addToQueue, addMultipleSequencesToQueue } = useAudioQueue(); // Hook quản lý hàng đợi âm thanh

            // Tính toán tổng điểm (Giữ nguyên thứ tự người chơi khi họ được thêm vào)
            const unsortedPlayerScores = useMemo(() => {
                return players.map(p => {
                    const totalScore = history.reduce((sum, round) => sum + (round.scores[p.id] || 0), 0);
                    return { ...p, totalScore: Number(totalScore) }; // Đảm bảo totalScore là Number
                }); 
            }, [players, history]);

            // --- Logic Audio 4. Phát âm thanh đọc điểm VÁN MỚI (Sắp xếp theo điểm ván) ---
            const playScoreAudio = (currentRoundScores) => {
                
                // 1. Tạo mảng chi tiết điểm, có điểm ván vừa ghi
                const scoreDetails = players.map(p => ({
                    name: p.name,
                    // LẤY ĐIỂM VÁN VỪA GHI VÀ CHUYỂN RÕ RÀNG SANG NUMBER ĐỂ SẮP XẾP CHÍNH XÁC
                    score: Number(currentRoundScores[p.id] || 0), 
                    id: p.id
                }));
                
                // 2. Sắp xếp theo điểm ván vừa ghi (cao -> thấp)
                // Dùng phép trừ thuần túy để đảm bảo so sánh số học, không phải so sánh chuỗi
                scoreDetails.sort((a, b) => b.score - a.score);

                let allAudioSequences = [];
                
                scoreDetails.forEach(detail => {
                    const nameFile = normalizeName(detail.name); 
                    const scoreFile = detail.score.toString(); 

                    // Thêm logic kiểm tra (giả định chỉ đọc được từ -10 đến 10)
                    if (detail.score < -10 || detail.score > 10) {
                        console.warn(`[CẢNH BÁO AUDIO VÁN] Điểm ${detail.score} của ${detail.name} nằm ngoài phạm vi đọc (-10 đến 10) thông thường. Hãy đảm bảo có file âm thanh "${scoreFile}.mp3".`);
                    }

                    // Chuỗi phát mới: [Tên người chơi], [Điểm VÁN VỪA GHI]
                    const audioSequence = [nameFile, scoreFile];
                    
                    allAudioSequences.push(audioSequence);
                });
                
                // Gửi tất cả các chuỗi để được tải trước và phát liền mạch
                addMultipleSequencesToQueue(allAudioSequences);
            };

            // Logic Audio 6a. Phát thông báo ván còn lại
            const playLowRoundAudio = useCallback((roundsLeft) => {
                let audioFile = null;
                if (roundsLeft === 3) {
                    audioFile = '3left';
                } else if (roundsLeft === 2) {
                    audioFile = '2left';
                } else if (roundsLeft === 1) {
                    audioFile = '1left';
                }
                if (audioFile) {
                    addToQueue([audioFile]);
                }
            }, [addToQueue]);


            // --- 5. Lịch sử điểm và Tổng kết ván (useEffect chính) ---
            useEffect(() => {
                const roundsLimit = parseInt(maxRounds);
                const currentRound = history.length;
                
                if (gameState !== 'playing' || roundsLimit <= 0) return;

                const roundsLeft = roundsLimit - currentRound;
                let delayTimer = null;

                // 1. Logic Game Over - KHI ĐẠT GIỚI HẠN VÁN
                if (currentRound >= roundsLimit) {
                    setGameState('game_over');
                    
                    // Yêu cầu 2: Đã đọc điểm ván vừa rồi (từ handleConfirmScore), giờ CHỈ cần phát gameover.mp3
                    addToQueue(['gameover']); 
                    
                    return; // Game is over
                }

                // 2. Logic Low Rounds Notification
                if (currentRound > 0) { 
                    // Set timeout 5s để đảm bảo nó phát sau khi chuỗi audio điểm ván mới kết thúc
                    delayTimer = setTimeout(() => {
                        playLowRoundAudio(roundsLeft);
                    }, 5000); 
                }
                
                return () => {
                    if (delayTimer) {
                        clearTimeout(delayTimer);
                    }
                };
            // Loại bỏ playLoserAudio khỏi dependency vì nó không được dùng ở đây nữa
            }, [history, maxRounds, gameState, players, addToQueue, playLowRoundAudio, unsortedPlayerScores]); 
            
            // Khởi tạo/Cập nhật input scores khi players thay đổi 
            useEffect(() => {
                 if (players.length > 0 && gameState === 'playing' && Object.keys(roundScoreInputs).length === 0) {
                    const initialInputs = players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                    setRoundScoreInputs(initialInputs);
                }
            }, [players, gameState, roundScoreInputs]);


            // --- 7. Hoàn tác (Undo) ---
            const handleUndo = () => {
                if (history.length === 0) return;

                setModal({
                    isOpen: true,
                    type: 'confirm_undo',
                    data: { message: `Bạn có chắc chắn muốn hoàn tác Ván ${history.length} không?` }
                });
            };

            const confirmUndo = () => {
                setHistory(prev => prev.slice(0, -1)); // Xóa ván cuối cùng
                setGameState('playing');
                setIsScoringMode(false);
                setRoundScoreInputs({});
                setModal({ isOpen: false, type: null, data: null });
            };


            // --- Xử lý Stage: Setup (Giai đoạn I) ---

            const handlePlayerToggle = (player) => {
                const newPlayers = players.find(p => p.id === player.id) 
                    ? players.filter(p => p.id !== p.id)
                    : [...players, player];
                
                if (newPlayers.length > MAX_PLAYERS) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Thông báo', message: `Số lượng người chơi tối đa là ${MAX_PLAYERS}.` }
                    });
                    return;
                }
                // setPlayers sẽ giữ thứ tự thêm vào
                setPlayers(newPlayers);
            };

            const handleAddNewPlayer = () => {
                if (newPlayerName && players.length < MAX_PLAYERS) {
                    if (players.some(p => p.name.toLowerCase() === newPlayerName.trim().toLowerCase())) {
                         setModal({
                            isOpen: true,
                            type: 'info',
                            data: { title: 'Thông báo', message: `Người chơi '${newPlayerName}' đã tồn tại.` }
                        });
                        return;
                    }
                    
                    const normalizedName = normalizeName(newPlayerName);
                    const newPlayer = { id: normalizedName + generateId(), name: newPlayerName.trim() }; 
                    setPlayers([...players, newPlayer]);
                    setNewPlayerName('');
                } else if (players.length >= MAX_PLAYERS) {
                     setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Thông báo', message: `Số lượng người chơi tối đa là ${MAX_PLAYERS}.` }
                    });
                }
            };
            
            const handleStartGame = () => {
                if (players.length < 2) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Lỗi', message: 'Cần tối thiểu 2 người chơi để bắt đầu trò chơi.' }
                    });
                    return;
                }
                
                const finalMaxRounds = parseInt(maxRounds);
                if (isNaN(finalMaxRounds) || finalMaxRounds < 1) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Lỗi', message: 'Số ván chơi phải là một số nguyên dương hợp lệ (tối thiểu 1).' }
                    });
                    setMaxRounds(15); 
                    return;
                }

                setMaxRounds(finalMaxRounds); 
                setGameState('playing');
                const initialInputs = players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                setRoundScoreInputs(initialInputs);
            };


            // --- Xử lý Stage: Playing (Giai đoạn II) ---

            const handleNewScoreClick = () => {
                if (!isScoringMode) {
                    addToQueue(['vanmoi']); 
                    setIsScoringMode(true);
                    const initialInputs = unsortedPlayerScores.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                    setRoundScoreInputs(initialInputs);
                } else {
                    handleConfirmScore();
                }
            };

            const handleScoreChange = (playerId, value) => {
                const numValue = value === '' ? '' : parseInt(value);
                setRoundScoreInputs(prev => ({ ...prev, [playerId]: isNaN(numValue) ? value : numValue }));
            };

            const handleConfirmScore = () => {
                const newRoundScores = {};

                // Chuẩn hóa điểm
                unsortedPlayerScores.forEach(p => {
                    const score = roundScoreInputs[p.id];
                    if (score === '' || score === null || isNaN(score)) {
                        newRoundScores[p.id] = 0; 
                    } else {
                        newRoundScores[p.id] = parseInt(score); 
                    }
                });

                // Ghi kết quả vào lịch sử
                const newHistoryEntry = {
                    round: history.length + 1,
                    scores: newRoundScores,
                    timestamp: new Date().toISOString()
                };
                setHistory(prev => [...prev, newHistoryEntry]);

                // Phát âm thanh theo logic mới (sắp xếp theo điểm ván vừa ghi)
                // ĐIỂM VÁN MỚI ĐƯỢC ĐỌC TẠI ĐÂY
                playScoreAudio(newRoundScores);

                // Reset trạng thái
                setIsScoringMode(false);
                setRoundScoreInputs({});
            };
            
            const handleSetRoundsClick = () => {
                 setModal({
                    isOpen: true,
                    type: 'reset_rounds',
                    data: { currentMax: parseInt(maxRounds) || 15, playedRounds: history.length }
                });
                setNewMaxRoundsInput(parseInt(maxRounds) || 15);
            };

            const confirmResetRounds = () => {
                const newMax = parseInt(newMaxRoundsInput);
                if (isNaN(newMax) || newMax <= 0) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Lỗi', message: 'Số ván mới phải là một số nguyên dương hợp lệ.' }
                    });
                    return;
                }
                if (newMax < history.length) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Lỗi', message: `Số ván mới (${newMax}) không được nhỏ hơn số ván đã chơi (${history.length}).` }
                    });
                    return;
                }
                setMaxRounds(newMax);
                setModal({ isOpen: false, type: null, data: null });
                
                // Kiểm tra nếu việc tăng maxRounds lại khiến game kết thúc ngay lập tức
                if (history.length >= newMax) {
                    // Xử lý tương tự logic cho Game Over THỦ CÔNG (Chỉ phát gameover.mp3)
                    setGameState('game_over');
                    addToQueue(['gameover']); 
                }
            };

            const renderModalContent = () => {
                switch (modal.type) {
                    case 'info':
                        return <div><p className="text-gray-700">{modal.data.message}</p></div>;
                    case 'confirm_undo':
                        return <div><p className="text-gray-700">{modal.data.message}</p></div>;
                    case 'reset_rounds':
                        return (
                            <div>
                                <p className="text-gray-700 mb-4">
                                    Ván đã chơi: <span className="font-bold text-primary">{modal.data.playedRounds}</span>.
                                    Số ván tối thiểu phải là <span className="font-bold text-primary">{modal.data.playedRounds}</span>.
                                </p>
                                <label className="block text-sm font-medium text-gray-700">Nhập số ván mới:</label>
                                <input
                                    type="number"
                                    min={modal.data.playedRounds}
                                    value={newMaxRoundsInput}
                                    onChange={(e) => setNewMaxRoundsInput(e.target.value)}
                                    className="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:ring-primary focus:border-primary"
                                />
                            </div>
                        );
                    default:
                        return null;
                }
            };

            // --- Render các Stage ---
            
            // Stage 0: Setup
            const renderSetup = () => (
                <div className="p-4 sm:p-6 pb-2">
                    <h2 className="text-xl font-bold text-primary mb-4 text-center">⚙️ Cấu Hình Trò Chơi</h2>

                    {/* Chọn Số Ván */}
                    <div className="mb-4 p-3 bg-white rounded-lg shadow-sm border border-gray-200">
                        <h3 className="text-md font-semibold mb-2 text-gray-700">1. Chọn Số Ván Chơi (Hiện tại: {parseInt(maxRounds) || 15})</h3>
                        <div className="flex flex-wrap gap-2 mb-2">
                            {PRESET_ROUNDS.map(r => (
                                <button
                                    key={r}
                                    onClick={() => setMaxRounds(r)}
                                    className={`px-3 py-1 text-sm font-medium rounded-full transition ${parseInt(maxRounds) === r ? 'bg-primary text-white shadow-md' : 'bg-gray-200 text-gray-700'}`}
                                >
                                    {r} Ván
                                </button>
                            ))}
                        </div>
                        <input
                            type="number"
                            min="1"
                            value={maxRounds} 
                            onChange={(e) => setMaxRounds(e.target.value)} 
                            onBlur={(e) => {
                                const val = parseInt(e.target.value);
                                if (isNaN(val) || val < 1) {
                                    setMaxRounds(1);
                                } else {
                                     setMaxRounds(val);
                                }
                            }}
                            className="w-full p-2 border border-gray-300 rounded-lg text-sm mt-1 focus:ring-secondary focus:border-secondary"
                        />
                    </div>
                    
                    {/* Chọn Người Chơi */}
                    <div className="mb-4 p-3 bg-white rounded-lg shadow-sm border border-gray-200">
                        <h3 className="text-md font-semibold mb-2 text-gray-700">2. Chọn Người Chơi</h3>
                        
                        {/* Danh sách chọn sẵn */}
                        <div className="flex flex-wrap gap-2 border-b pb-3 mb-3">
                            {PRESET_PLAYERS.map(name => {
                                const id = normalizeName(name);
                                const player = { id: id, name: name }; 
                                const isSelected = players.some(p => p.id === id);
                                return (
                                    <button
                                        key={name}
                                        onClick={() => handlePlayerToggle(player)}
                                        className={`px-3 py-1 text-sm rounded-full transition ${isSelected ? 'bg-secondary text-white font-semibold shadow-sm' : 'bg-gray-100 text-gray-600'} disabled:opacity-50`}
                                        disabled={!isSelected && players.length >= MAX_PLAYERS}
                                    >
                                        {name} {isSelected ? '✅' : ''}
                                    </button>
                                );
                            })}
                        </div>

                        {/* Thêm người chơi mới */}
                        <div className="flex space-x-2">
                            <input
                                type="text"
                                value={newPlayerName}
                                onChange={(e) => setNewPlayerName(e.target.value)}
                                placeholder="Tên người chơi mới..."
                                className="flex-grow p-2 text-sm border border-gray-300 rounded-lg focus:ring-primary focus:border-primary"
                                disabled={players.length >= MAX_PLAYERS}
                            />
                            <button
                                onClick={handleAddNewPlayer}
                                className="p-2 bg-primary text-white rounded-lg font-semibold text-sm transition disabled:bg-gray-400"
                                disabled={!newPlayerName.trim() || players.length >= MAX_PLAYERS}
                            >
                                Thêm
                            </button>
                        </div>
                        
                    </div>

                    {/* Danh sách người chơi đã chọn */}
                    <div className="mb-4 p-3 bg-indigo-50 rounded-lg border border-indigo-200">
                        <h3 className="text-md font-semibold text-primary mb-2">Người chơi đã chọn ({players.length}/{MAX_PLAYERS}):</h3>
                        <div className="flex flex-wrap gap-2">
                            {players.map(p => (
                                <span key={p.id} className="bg-primary text-white text-xs px-3 py-1 rounded-full flex items-center">
                                    {p.name}
                                    <button 
                                        onClick={() => handlePlayerToggle(p)}
                                        className="ml-2 text-white/80 font-bold text-xs"
                                    >
                                        &times;
                                    </button>
                                </span>
                            ))}
                        </div>
                        {players.length === 0 && <p className="text-sm text-gray-500 italic mt-2">Chưa có người chơi nào được chọn.</p>}
                    </div>

                    {/* Nút Bắt đầu */}
                    <button
                        onClick={handleStartGame}
                        disabled={players.length < 2}
                        className="w-full py-3 bg-secondary text-white font-bold text-lg rounded-xl shadow-lg transition disabled:bg-gray-400"
                    >
                        {players.length < 2 ? 'Cần 2 người chơi để bắt đầu' : `BẮT ĐẦU TRÒ CHƠI (${parseInt(maxRounds) || 15} VÁN)`}
                    </button>
                </div>
            );

            // Stage 1: Playing
            const renderPlaying = () => (
                <div className="p-4 sm:p-6">
                    <h2 className="text-xl sm:text-2xl font-bold text-primary mb-4 text-center">
                        VÁN {history.length + 1} / {parseInt(maxRounds) || 15}
                    </h2>
                    
                    {/* Nút Ghi/Xác nhận điểm */}
                     <button
                        onClick={handleNewScoreClick}
                        className={`w-full py-3 font-bold text-white rounded-xl shadow-lg transition duration-300 transform mb-4 ${isScoringMode ? 'bg-warning animate-pulse-slow' : 'bg-primary'}`}
                        disabled={unsortedPlayerScores.length === 0}
                    >
                        {isScoringMode ? 'XÁC NHẬN GHI ĐIỂM VÁN NÀY' : 'GHI ĐIỂM VÁN MỚI'}
                    </button>
                    
                    {/* Vùng Hiện Thị Tên Người Chơi và Ghi Điểm */}
                    <div className={`p-4 rounded-xl shadow-lg mb-4 border transition duration-300 ${isScoringMode ? 'bg-indigo-50 border-indigo-200 animate-fade-in' : 'bg-white border-gray-200'}`}>
                        <h3 className="text-xl font-bold text-gray-700 mb-3 border-b pb-2">
                            {isScoringMode ? 'Nhập Điểm Ván Mới' : 'Người Chơi'}
                        </h3>
                        <div className="space-y-3">
                            {/* Dùng danh sách không sắp xếp để đảm bảo thứ tự thống nhất */}
                            {players.map(p => ( 
                                <div key={p.id} className="flex justify-between items-center py-1">
                                    {/* Tên người chơi */}
                                    <span className={`text-lg font-medium text-gray-800 ${isScoringMode ? 'w-1/2' : 'flex-grow'} truncate`}>
                                        {p.name}
                                    </span>
                                    
                                    {/* Scoring Input/Controls: Chỉ hiển thị nếu isScoringMode là true */}
                                    {isScoringMode && (
                                        <div className="grid grid-cols-3 w-1/2 gap-1">
                                            {/* Nút Giảm */}
                                            <button 
                                                onClick={() => handleScoreChange(p.id, (parseInt(roundScoreInputs[p.id]) || 0) - 1)}
                                                className="p-2 bg-danger text-white rounded-lg font-bold text-base transition hover:bg-danger/80"
                                            >
                                                -
                                            </button>
                                            {/* Input Điểm */}
                                            <input
                                                type="number"
                                                value={roundScoreInputs[p.id] === 0 && roundScoreInputs[p.id] !== '' ? '0' : roundScoreInputs[p.id]}
                                                onChange={(e) => handleScoreChange(p.id, e.target.value)}
                                                className="p-1 border border-gray-300 rounded-lg text-center font-mono text-xl focus:ring-secondary focus:border-secondary"
                                                placeholder="0"
                                            />
                                            {/* Nút Tăng */}
                                            <button 
                                                onClick={() => handleScoreChange(p.id, (parseInt(roundScoreInputs[p.id]) || 0) + 1)}
                                                className="p-2 bg-secondary text-white rounded-lg font-bold text-base transition hover:bg-secondary/80"
                                            >
                                                +
                                            </button>
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>
                    
                    
                    {/* Các nút chức năng */}
                    <div className="flex justify-between space-x-2 mb-4">
                         <button
                            onClick={handleUndo}
                            disabled={history.length === 0 || isScoringMode}
                            className="flex-1 py-2 bg-warning text-white font-semibold rounded-lg transition disabled:bg-gray-400 text-sm hover:bg-warning/80"
                        >
                            ↩️ Hoàn Tác
                        </button>
                        <button
                            onClick={handleSetRoundsClick}
                            disabled={isScoringMode}
                            className="flex-1 py-2 bg-blue-500 text-white font-semibold rounded-lg transition disabled:bg-gray-400 text-sm hover:bg-blue-500/80"
                        >
                            🔁 Set Ván
                        </button>
                        <button
                            onClick={() => {
                                setGameState('game_over');
                                
                                // Yêu cầu 1 (Kết thúc bằng nút): CHỈ phát gameover.mp3
                                addToQueue(['gameover']); 
                            }}
                            disabled={isScoringMode}
                            className="flex-1 py-2 bg-gray-600 text-white font-semibold rounded-lg transition disabled:bg-gray-400 text-sm hover:bg-gray-600/80"
                        >
                            🛑 Kết Thúc
                        </button>
                    </div>
                    
                    
                    {/* Lịch sử điểm (Đã tối ưu cuộn ngang) */}
                    <div className="bg-white p-4 rounded-xl shadow-lg">
                        <button 
                            onClick={() => setShowHistory(prev => !prev)}
                            className="w-full text-left text-lg font-semibold text-gray-700 mb-2 p-2 rounded-lg transition flex justify-between items-center hover:bg-gray-100"
                        >
                            Lịch Sử Điểm Chi Tiết ({history.length} Ván) {showHistory ? '▲' : '▼'}
                        </button>
                        {showHistory && (
                            <div className="overflow-x-auto mt-2 max-h-64">
                                <table className="min-w-full divide-y divide-gray-200">
                                    <thead className="bg-gray-50 sticky left-0 z-10">
                                        <tr>
                                            {/* Cột Tên Người Chơi (Fixed/Sticky) */}
                                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase sticky left-0 bg-gray-50 shadow-sm">Người chơi</th>
                                            {/* Cột Điểm các Ván (Cuộn) */}
                                            {[...Array(history.length)].map((_, index) => (
                                                <th key={index} className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase min-w-[50px]">Ván {history.length - index}</th>
                                            ))}
                                        </tr>
                                    </thead>
                                    <tbody className="bg-white divide-y divide-gray-200">
                                        {/* Dùng players state (unsorted) để đảm bảo thứ tự thống nhất */}
                                        {players.map(p => (
                                            <tr key={p.id}>
                                                {/* Dữ liệu Tên Người Chơi (Fixed/Sticky) */}
                                                <td 
                                                    className="px-3 py-2 whitespace-nowrap text-sm font-medium text-gray-900 sticky left-0 bg-white shadow-sm truncate" 
                                                    title={p.name}
                                                >
                                                    {p.name}
                                                </td>
                                                {/* Dữ liệu Điểm các Ván (Cuộn) - Hiển thị từ ván mới nhất về cũ nhất */}
                                                {[...history].reverse().map(entry => {
                                                    const score = entry.scores[p.id] || 0;
                                                    const colorClass = score > 0 ? 'text-secondary font-bold' : (score < 0 ? 'text-danger' : 'text-gray-500');
                                                    return (
                                                        <td key={entry.round} className={`px-3 py-2 whitespace-nowrap text-sm text-center ${colorClass} min-w-[50px] font-mono`}>
                                                            {score > 0 ? `+${score}` : score}
                                                        </td>
                                                    );
                                                })}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </div>
                </div>
            );

            // Stage 2: Game Over (Hiển thị Bảng Xếp Hạng cuối cùng)
            const renderGameOver = () => (
                <div className="p-6 text-center animate-bounce-in">
                    <h2 className="text-4xl font-extrabold text-danger mb-6">🎉 TRÒ CHƠI KẾT THÚC! 🎉</h2>
                    <p className="text-xl font-medium text-gray-700 mb-8">Tổng số ván đã chơi: <span className="text-primary font-bold">{history.length}</span></p>

                    {/* Bảng Xếp Hạng (SẮP XẾP THEO TỔNG ĐIỂM) */}
                    <div className="bg-white p-6 rounded-xl shadow-2xl mb-8">
                        <h3 className="text-2xl font-bold text-primary mb-4 border-b pb-2">🏆 BẢNG XẾP HẠNG</h3>
                        {/* Sắp xếp unsortedPlayerScores theo tổng điểm */}
                        {[...unsortedPlayerScores].sort((a, b) => b.totalScore - a.totalScore).map((p, index) => (
                            <div 
                                key={p.id} 
                                className={`flex justify-between items-center py-3 px-4 my-2 rounded-lg transition transform duration-300 ${index === 0 ? 'bg-yellow-100 border-2 border-warning scale-105 shadow-lg' : 'bg-gray-50'}`}
                            >
                                <span className={`text-xl font-bold ${index === 0 ? 'text-warning' : 'text-gray-700'}`}>
                                    {index + 1}. {p.name}
                                </span>
                                <span className={`text-3xl font-extrabold ${p.totalScore >= 0 ? 'text-secondary' : 'text-danger'} font-mono`}>
                                    {p.totalScore}
                                </span>
                            </div>
                        ))}
                    </div>

                    {/* Lịch sử điểm tại màn hình Game Over */}
                    <div className="bg-white p-4 rounded-xl shadow-lg mb-8">
                        <button 
                            onClick={() => setShowGameOverHistory(prev => !prev)}
                            className="w-full text-left text-lg font-semibold text-gray-700 mb-2 p-2 rounded-lg transition flex justify-between items-center hover:bg-gray-100"
                        >
                            Lịch Sử Điểm Chi Tiết ({history.length} Ván) {showGameOverHistory ? '▲' : '▼'}
                        </button>
                        {showGameOverHistory && (
                            <div className="overflow-x-auto mt-2 max-h-64">
                                <table className="min-w-full divide-y divide-gray-200">
                                    <thead className="bg-gray-50 sticky left-0 z-10">
                                        <tr>
                                            <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase sticky left-0 bg-gray-50 shadow-sm">Người chơi</th>
                                            {[...Array(history.length)].map((_, index) => (
                                                <th key={index} className="px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase min-w-[50px]">Ván {history.length - index}</th>
                                            ))}
                                        </tr>
                                    </thead>
                                    <tbody className="bg-white divide-y divide-gray-200">
                                        {/* Dùng players state (unsorted) để đảm bảo thứ tự thống nhất */}
                                        {players.map(p => (
                                            <tr key={p.id}>
                                                <td 
                                                    className="px-3 py-2 whitespace-nowrap text-sm font-medium text-gray-900 sticky left-0 bg-white shadow-sm truncate" 
                                                    title={p.name}
                                                >
                                                    {p.name}
                                                </td>
                                                {[...history].reverse().map(entry => {
                                                    const score = entry.scores[p.id] || 0;
                                                    const colorClass = score > 0 ? 'text-secondary font-bold' : (score < 0 ? 'text-danger' : 'text-gray-500');
                                                    return (
                                                        <td key={entry.round} className={`px-3 py-2 whitespace-nowrap text-sm text-center ${colorClass} min-w-[50px] font-mono`}>
                                                            {score > 0 ? `+${score}` : score}
                                                        </td>
                                                    );
                                                })}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </div>

                    {/* Nút Chơi Lại */}
                    <button
                        onClick={() => {
                            setGameState('setup');
                            setPlayers([]);
                            setHistory([]);
                            setIsScoringMode(false);
                            setRoundScoreInputs({});
                            setMaxRounds(15); 
                            localStorage.clear(); 
                            window.location.reload(); 
                        }}
                        className="w-full py-3 bg-secondary text-white font-bold text-xl rounded-xl shadow-lg transition hover:bg-secondary/80"
                    >
                        CHƠI LẠI
                    </button>
                </div>
            );
            
            // --- Logic Render Chính ---

            return (
                <div className="min-h-screen bg-gray-50 flex justify-center">
                    <div className="w-full max-w-xl mx-auto bg-white shadow-xl rounded-2xl overflow-hidden my-0 sm:my-4">
                        <header className="bg-primary text-white p-3 text-center">
                            <h1 className="text-2xl font-extrabold">GHI ĐIỂM TRÒ CHƠI</h1>
                        </header>
                        
                        {gameState === 'setup' && renderSetup()}
                        {gameState === 'playing' && renderPlaying()}
                        {gameState === 'game_over' && renderGameOver()}
                    </div>

                    {/* Modal Popup */}
                    <Modal
                        title={modal.type === 'info' ? 'Thông báo' : modal.type === 'confirm_undo' ? 'Xác nhận Hoàn tác' : 'Set lại Số Ván Chơi'}
                        isOpen={modal.isOpen}
                        onClose={() => setModal({ isOpen: false, type: null, data: null })}
                        onConfirm={modal.type === 'confirm_undo' ? confirmUndo : 
                                   modal.type === 'reset_rounds' ? confirmResetRounds :
                                   () => setModal({ isOpen: false, type: null, data: null }) 
                                  }
                        confirmText={modal.type === 'info' ? 'Đóng' : 'Xác nhận'}
                        showCancel={modal.type !== 'info'}
                        content={renderModalContent()}
                    />
                </div>
            );
        }

        // Render ứng dụng React vào DOM
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

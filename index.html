<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄüìàüöÄüìàüöÄ</title>
    <link rel="icon" type="image/png" href="images/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#4f46e5', // Indigo 600
                        'secondary': '#10b981', // Emerald 500
                        'warning': '#f59e0b', // Amber 500
                        'danger': '#ef4444', // Red 500
                    },
                    boxShadow: {
                        '3xl': '0 35px 60px -15px rgba(0, 0, 0, 0.3)',
                    },
                    keyframes: {
                        'fade-in': {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' },
                        },
                        'bounce-in': {
                            '0%': { transform: 'scale(0.9)', opacity: '0' },
                            '60%': { transform: 'scale(1.05)', opacity: '1' },
                            '100%': { transform: 'scale(1)' },
                        },
                        'pulse-strong': {
                            '0%, 100%': { transform: 'scale(1)', filter: 'brightness(1)' },
                            '50%': { transform: 'scale(1.05)', filter: 'brightness(1.1)' },
                        }
                    },
                    animation: {
                        'fade-in': 'fade-in 0.3s ease-out',
                        'bounce-in': 'bounce-in 0.4s ease-out',
                        'pulse-strong': 'pulse-strong 1.5s infinite',
                    }
                }
            }
        }
    </script>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-use-localstorage-state/lib/index.umd.js"></script> 
    
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;
        const useLocalStorageState = ReactUseLocalStorageState.useLocalStorageState; // L·∫•y hook t·ª´ th∆∞ vi·ªán
        
        const MAX_PLAYERS = 4;
        
        // C·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n cho √¢m thanh c·ª•c b·ªô
        const AUDIO_BASE_PATH = 'audio/';
        
        // Audio d·ª± ph√≤ng cho ng∆∞·ªùi ch∆°i t·ª± th√™m t·ª´ b√†n ph√≠m
        const FALLBACK_AUDIOS = ['member1', 'member2', 'member3', 'member4']; 

        // Danh s√°ch t√™n ng∆∞·ªùi ch∆°i c√≥ s·∫µn
        const PRESET_PLAYERS = [
            "B√¨nh ƒê·∫∑ng", 
            "D≈©ng Ho√†ng", 
            "D≈©ng Nguy·ªÖn", 
            "ƒê·ªãnh Ng√¥", 
            "ƒê√¥ng L√™", 
            "Kh√°nh ƒê·ªó", 
            "Minh Anh", 
            "Nh√¢n Tr·∫ßn", 
            "Qu√Ω Hu·ª≥nh", 
            "Tr√∫c Tr·∫ßn"
        ];
        const PRESET_ROUNDS = [15, 21, 31];
        
        // --- C·∫§U H√åNH GITHUB API ---
        const GITHUB_TOKEN_PART1 = 'github_pat_11AHU2I4Q0eTQynszWYAnj_';
        const GITHUB_TOKEN_PART2 = 'g3icOcB6W3He3EFtkB3rEuvAIst0GQQf50IaXXPDllERWI7ZWWJF0pB4QeI'; 
        const GITHUB_TOKEN = GITHUB_TOKEN_PART1 + GITHUB_TOKEN_PART2; 
        const REPO_OWNER = 'duphan97';
        const REPO_NAME = '13cay';
        const DATA_FILE_PATH = 'data/session_history.json'; 
        const GITHUB_API_URL = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${DATA_FILE_PATH}`;
        // --- H·∫æT C·∫§U H√åNH GITHUB API ---


        // --- 1. Custom Hooks & Utilities ---

        // H√†m chu·∫©n h√≥a t√™n ng∆∞·ªùi ch∆°i th√†nh t√™n file kh√¥ng d·∫•u, kh√¥ng kho·∫£ng tr·∫Øng, ch·ªØ th∆∞·ªùng
        const normalizeName = (name) => {
            return name
                .toLowerCase()
                .normalize("NFD")
                .replace(/[\u00c0-\u036f]/g, "") // b·ªè d·∫•u
                .replace(/ƒë/g, 'd')             // ƒë·ªïi ƒë -> d
                .replace(/\s+/g, '');           // b·ªè kho·∫£ng tr·∫Øng
        };

        // H√†m t·∫°o ID duy nh·∫•t
        const generateId = () => Math.random().toString(36).substring(2, 9);
        
        // H√ÄM T·∫†O ƒê·ªêI T∆Ø·ª¢NG NG∆Ø·ªúI CH∆†I HO√ÄN CH·ªàNH (v·ªõi audioFile)
        const createPlayerObject = (name, isCustom = false, existingPlayers = []) => {
            const normalizedName = normalizeName(name);
            let audioFileName = normalizedName;
            
            // ID d·ª±a tr√™n t√™n chu·∫©n h√≥a + ID ng·∫´u nhi√™n ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh duy nh·∫•t
            const id = normalizedName + generateId(); 

            if (isCustom) {
                // L·ªçc ra c√°c file d·ª± ph√≤ng ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng
                const usedFallbacks = existingPlayers
                    .map(p => p.audioFile)
                    .filter(audio => FALLBACK_AUDIOS.includes(audio));
                
                // T√¨m file d·ª± ph√≤ng ƒë·∫ßu ti√™n ch∆∞a ƒë∆∞·ª£c s·ª≠ d·ª•ng
                const availableFallback = FALLBACK_AUDIOS.find(f => !usedFallbacks.includes(f));

                if (availableFallback) {
                    audioFileName = availableFallback;
                } else {
                    // N·∫øu qu√° 4 ng∆∞·ªùi ch∆°i t·ª± th√™m, quay l·∫°i d√πng t√™n chu·∫©n h√≥a (c·∫ßn file ri√™ng)
                    audioFileName = normalizedName;
                    console.warn("ƒê√£ s·ª≠ d·ª•ng h·∫øt file audio d·ª± ph√≤ng (member1-4). Ng∆∞·ªùi ch∆°i m·ªõi s·∫Ω d√πng t√™n chu·∫©n h√≥a, c·∫ßn file audio t∆∞∆°ng ·ª©ng.");
                }
            } else {
                // Ng∆∞·ªùi ch∆°i trong danh s√°ch c√≥ s·∫µn, s·ª≠ d·ª•ng t√™n chu·∫©n h√≥a
                audioFileName = normalizedName;
            }
            
            return { id, name: name.trim(), audioFile: audioFileName };
        };


        // Custom Hook: X·ª≠ l√Ω Audio theo h√†ng ƒë·ª£i
        const useAudioQueue = () => {
            const audioQueue = useRef([]); 
            const isPlaying = useRef(false); 

            const preloadAudioSequence = useCallback((soundNames) => {
                
                const loadAudioWithRetry = (name, maxRetries = 3) => {
                    if (!name || name === '') {
                        return Promise.resolve(null);
                    }
                    
                    const fullPath = `${AUDIO_BASE_PATH}${name}.mp3`;
                    const audio = new Audio(fullPath);
                    audio.volume = 0.8;
                    let attempts = 0;

                    return new Promise((resolve, reject) => {
                        const tryLoad = () => {
                            attempts++;
                            
                            if (audio.readyState >= 2) { 
                                resolve(audio);
                                return;
                            }
                            
                            const handleSuccess = () => {
                                audio.removeEventListener('error', handleError); 
                                resolve(audio);
                            };
                            
                            const handleError = (e) => {
                                audio.removeEventListener('canplaythrough', handleSuccess);
                                audio.removeEventListener('error', handleError); 
                                
                                if (attempts < maxRetries) {
                                    setTimeout(tryLoad, 500); 
                                } else {
                                    console.error(`[L·ªñI T·∫¢I FILE] Th·∫•t b·∫°i sau ${maxRetries} l·∫ßn th·ª≠ cho: ${audio.src}. B·ªè qua file.`);
                                    reject(new Error(`Failed to load ${audio.src}.`));
                                }
                            };

                            audio.addEventListener('canplaythrough', handleSuccess, { once: true });
                            audio.addEventListener('error', handleError, { once: true });
                            
                            audio.load();
                        };
                        
                        tryLoad();
                    });
                };

                const loadPromises = soundNames.map(name => loadAudioWithRetry(name).catch(e => {
                    console.warn(`T·∫£i file "${name}.mp3" th·∫•t b·∫°i, s·∫Ω b·ªè qua.`);
                    return null;
                }));


                return Promise.all(loadPromises)
                    .then(audioObjects => audioObjects.filter(obj => obj !== null))
                    .catch(error => {
                        console.warn('To√†n b·ªô chu·ªói ph√°t √¢m thanh n√†y ƒë√£ b·ªã b·ªè qua do l·ªói t·∫£i file ƒë√£ ƒë∆∞·ª£c ghi nh·∫≠n ·ªü tr√™n.');
                        return []; 
                    });

            }, []);

            const playNext = useCallback(() => {
                if (audioQueue.current.length > 0 && !isPlaying.current) {
                    isPlaying.current = true;
                    const currentSequence = audioQueue.current.shift(); 
                    let currentAudioIndex = 0;

                    const playSequence = () => {
                        if (currentAudioIndex >= currentSequence.length) {
                            isPlaying.current = false; 
                            playNext(); 
                            return;
                        }

                        const audio = currentSequence[currentAudioIndex];
                        
                        audio.onended = () => {
                            currentAudioIndex++;
                            playSequence(); 
                        };

                        audio.play().catch(e => {
                            console.warn("Autoplay was prevented or playback error:", audio.src, e);
                            currentAudioIndex++;
                            playSequence();
                        });
                    };

                    if (currentSequence.length > 0) {
                        playSequence();
                    } else {
                        isPlaying.current = false;
                        playNext();
                    }
                }
            }, []);

            const addToQueue = useCallback((soundNamesArray) => {
                const loadingPromise = preloadAudioSequence(soundNamesArray)
                    .then(preloadedAudioObjects => {
                        if (preloadedAudioObjects.length > 0) {
                            audioQueue.current.push(preloadedAudioObjects);
                        }
                    })
                    .finally(() => {
                        if (!isPlaying.current) {
                            playNext();
                        }
                    });

                return loadingPromise; 
            }, [playNext, preloadAudioSequence]);


            const addMultipleSequencesToQueue = useCallback((sequences) => {
                
                const loadingPromises = sequences.map(soundNamesArray => {
                     return preloadAudioSequence(soundNamesArray);
                });

                Promise.all(loadingPromises)
                    .then(allPreloadedSequences => {
                        allPreloadedSequences.forEach(preloadedAudioObjects => {
                            if (preloadedAudioObjects && preloadedAudioObjects.length > 0) {
                                audioQueue.current.push(preloadedAudioObjects);
                            }
                        });
                    })
                    .finally(() => {
                        if (!isPlaying.current) {
                            playNext();
                        }
                    });

            }, [playNext, preloadAudioSequence]);


            return { 
                addToQueue: addToQueue,
                addMultipleSequencesToQueue: addMultipleSequencesToQueue
            };
        };


        // --- Logic Ghi l·ªãch s·ª≠ l√™n GitHub (Y√™u c·∫ßu 5 & B·ªï sung ch·ªëng tr√πng l·∫∑p) ---
        // *** C·∫¨P NH·∫¨T: Th√™m 'isGameSaved', 'setIsGameSaved' l√†m tham s·ªë ***
        const useGitHubHistory = (sortedScores, gameState, history, startTime, isGameSaved, setIsGameSaved) => { 
            const historyRef = useRef([]); 
            const shaRef = useRef(null); 
            
            // B·ªé: const currentSessionKey = `game_saved_${history.length}`;
            
            const getAndSetSha = useCallback(async () => {
                try {
                    const response = await fetch(GITHUB_API_URL, {
                        headers: {
                            'Authorization': `token ${GITHUB_TOKEN}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });

                    if (response.status === 404) {
                        // File not found, need to create it
                        shaRef.current = null;
                        return [];
                    }

                    if (!response.ok) {
                        throw new Error(`GitHub GET failed with status: ${response.status}`);
                    }

                    const data = await response.json();
                    shaRef.current = data.sha;
                    
                    // Decode content
                    const decodedContent = atob(data.content);
                    // Decode Base64 string to original UTF-8 string
                    const utf8String = decodeURIComponent(escape(decodedContent));
                    
                    const existingHistory = JSON.parse(utf8String);
                    return Array.isArray(existingHistory) ? existingHistory : [];

                } catch (error) {
                    console.error("L·ªói khi l·∫•y l·ªãch s·ª≠ t·ª´ GitHub:", error);
                    shaRef.current = null;
                    return []; 
                }
            }, []);

            const saveHistoryToGithub = useCallback(async (currentSortedScores) => {
                // KI·ªÇM TRA LOCAL STORAGE TR∆Ø·ªöC KHI L∆ØU
                if (isGameSaved) {
                    console.log("L·ªãch s·ª≠ v√°n ch∆°i n√†y ƒë√£ ƒë∆∞·ª£c l∆∞u. B·ªè qua l∆∞u GitHub.");
                    return; // NgƒÉn ch·∫∑n vi·ªác l∆∞u tr√πng l·∫∑p
                }
                
                if (!currentSortedScores || currentSortedScores.length === 0) {
                    console.log("Kh√¥ng c√≥ ƒëi·ªÉm ƒë·ªÉ l∆∞u. B·ªè qua l∆∞u GitHub.");
                    return;
                }
                
                try {
                    // 1. L·∫•y l·ªãch s·ª≠ hi·ªán t·∫°i v√† SHA
                    const existingHistory = await getAndSetSha();
                    
                    // *** C·∫¨P NH·∫¨T: Th√™m startTime v√† endTime v√†o newEntry ***
                    const newEntry = {
                        startTime: startTime, // Th·ªùi gian b·∫Øt ƒë·∫ßu (t·ª´ state)
                        endTime: new Date().toISOString(), // Th·ªùi gian k·∫øt th√∫c (l√∫c l∆∞u)
                        game: currentSortedScores.map((p, index) => ({
                            name: p.name,
                            rank: index + 1, // Th·ª© h·∫°ng 1, 2, 3, 4
                        }))
                    };
                    
                    const newHistory = [...existingHistory, newEntry];
                    
                    // 3. Chu·∫©n b·ªã n·ªôi dung cho API (UTF-8 v√† Base64)
                    const contentString = JSON.stringify(newHistory, null, 2);
                    
                    // Encode UTF-8 string to Base64 (H·ªó tr·ª£ ti·∫øng Vi·ªát c√≥ d·∫•u)
                    const base64Content = btoa(unescape(encodeURIComponent(contentString)));
                    
                    const payload = {
                        message: `Ho√†n t·∫•t game v√†o l√∫c ${new Date().toLocaleString('vi-VN')}`,
                        content: base64Content,
                        sha: shaRef.current, // G·ª≠i SHA n·∫øu c√≥ (update)
                    };
                    
                    const response = await fetch(GITHUB_API_URL, {
                        method: shaRef.current ? 'PUT' : 'PUT', // D√πng PUT cho c·∫£ t·∫°o m·ªõi v√† update
                        headers: {
                            'Authorization': `token ${GITHUB_TOKEN}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`GitHub PUT/POST failed with status: ${response.status}`);
                    }

                    console.log("L·ªãch s·ª≠ tr√≤ ch∆°i ƒë√£ ƒë∆∞·ª£c l∆∞u th√†nh c√¥ng l√™n GitHub!");
                    // ƒê·∫∂T C·ªú B√ÅO HI·ªÜU L∆ØU TH√ÄNH C√îNG V√ÄO LOCAL STORAGE (TH√îNG QUA STATE)
                    setIsGameSaved(true);
                    
                    // C·∫≠p nh·∫≠t SHA m·ªõi
                    const result = await response.json();
                    shaRef.current = result.content.sha;

                } catch (error) {
                    console.error("L·ªñI C·∫§P CAO khi l∆∞u l·ªãch s·ª≠ l√™n GitHub:", error);
                    // Kh√¥ng ƒë·∫∑t c·ªù n·∫øu l∆∞u th·∫•t b·∫°i
                }
            // *** C·∫¨P NH·∫¨T: Th√™m startTime, isGameSaved, setIsGameSaved v√†o dependency array ***
            }, [getAndSetSha, startTime, isGameSaved, setIsGameSaved]); 
            
            // K√≠ch ho·∫°t vi·ªác l∆∞u khi chuy·ªÉn sang Game Over
            useEffect(() => {
                if (gameState === 'game_over' && history.length > 0) {
                    // Ch·ªâ l∆∞u khi c√≥ √≠t nh·∫•t 1 v√°n ƒë√£ ch∆°i
                    saveHistoryToGithub(sortedScores);
                }
            }, [gameState, sortedScores, saveHistoryToGithub, history.length]); 
        // *** K·∫æT TH√öC C·∫¨P NH·∫¨T ***
        };

        // --- 2. Component Con: Modal (Thay th·∫ø alert/confirm) ---

        const Modal = ({ title, content, isOpen, onClose, onConfirm, confirmText = "X√°c nh·∫≠n", cancelText = "H·ªßy b·ªè", showCancel = true }) => {
            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 animate-fade-in">
                    <div className="bg-white rounded-xl shadow-3xl w-full max-w-sm animate-bounce-in">
                        <header className="px-4 py-3 bg-primary rounded-t-xl">
                            <h3 className="text-xl font-bold text-white">{title}</h3>
                        </header>
                        <div className="p-4">
                            {content}
                        </div>
                        {/* CƒÉn gi·ªØa n√∫t x√°c nh·∫≠n */}
                        <footer className="flex justify-center space-x-3 p-4 border-t border-gray-100"> 
                            {showCancel && (
                                <button
                                    onClick={onClose}
                                    className="px-4 py-2 text-sm font-semibold text-gray-700 bg-gray-200 rounded-lg transition"
                                >
                                    {cancelText}
                                </button>
                            )}
                            <button
                                onClick={onConfirm}
                                className="px-4 py-2 text-sm font-semibold text-white bg-secondary rounded-lg transition"
                            >
                                {confirmText}
                            </button>
                        </footer>
                    </div>
                </div>
            );
        };

        // --- 3. Component Ch√≠nh: App ---

        function App() {
            // State ch√≠nh c·ªßa ·ª©ng d·ª•ng
            const [gameState, setGameState] = useLocalStorageState('gameState', 'setup'); 
            const [players, setPlayers] = useLocalStorageState('players', []);
            const [maxRounds, setMaxRounds] = useLocalStorageState('maxRounds', 15); 
            const [history, setHistory] = useLocalStorageState('history', []);
            
            // *** TH√äM M·ªöI: State cho startTime ***
            const [startTime, setStartTime] = useLocalStorageState('startTime', null); 
            
            // *** TH√äM M·ªöI: State cho c·ªù ch·ªëng tr√πng l·∫∑p GitHub (LocalStorage) ***
            const [isGameSaved, setIsGameSaved] = useLocalStorageState('isGameSaved', false);
            // *** K·∫æT TH√öC TH√äM M·ªöI ***

            const [showHistory, setShowHistory] = useState(false);
            const [showGameOverHistory, setShowGameOverHistory] = useState(false);
            const [isScoringMode, setIsScoringMode] = useState(false);
            const [newPlayerName, setNewPlayerName] = useState('');
            const [roundScoreInputs, setRoundScoreInputs] = useLocalStorageState('roundScoreInputs', {});
            const [modal, setModal] = useState({ isOpen: false, type: null, data: null });
            const [newMaxRoundsInput, setNewMaxRoundsInput] = useState(15);
            
            const { addToQueue, addMultipleSequencesToQueue } = useAudioQueue(); 

            // T√≠nh to√°n t·ªïng ƒëi·ªÉm (Gi·ªØ nguy√™n th·ª© t·ª± ng∆∞·ªùi ch∆°i khi h·ªç ƒë∆∞·ª£c th√™m v√†o)
            const unsortedPlayerScores = useMemo(() => {
                return players.map(p => {
                    const totalScore = history.reduce((sum, round) => sum + (round.scores[p.id] || 0), 0);
                    return { ...p, totalScore: Number(totalScore) };
                }); 
            }, [players, history]);
            
            // T√≠nh to√°n B·∫£ng x·∫øp h·∫°ng ƒë·ªÉ truy·ªÅn v√†o hook GitHub
            const sortedScores = useMemo(() => {
                return [...unsortedPlayerScores].sort((a, b) => b.totalScore - a.totalScore);
            }, [unsortedPlayerScores]);

            // *** C·∫¨P NH·∫¨T: K√≠ch ho·∫°t Hook l∆∞u l·ªãch s·ª≠ GitHub (Th√™m 'startTime', 'isGameSaved', 'setIsGameSaved') ***
            useGitHubHistory(sortedScores, gameState, history, startTime, isGameSaved, setIsGameSaved); 
            // *** K·∫æT TH√öC C·∫¨P NH·∫¨T ***


            // --- Logic Audio: Ph√°t √¢m thanh ƒë·ªçc ƒëi·ªÉm V√ÅN M·ªöI ---
            const playScoreAudio = (currentRoundScores) => {
                
                // 1. T·∫°o m·∫£ng chi ti·∫øt ƒëi·ªÉm, c√≥ ƒëi·ªÉm v√°n v·ª´a ghi
                const scoreDetails = players.map(p => ({
                    ...p, // ƒê√£ bao g·ªìm audioFile
                    score: Number(currentRoundScores[p.id] || 0), 
                }));
                
                // 2. S·∫Øp x·∫øp theo ƒëi·ªÉm v√°n v·ª´a ghi (cao -> th·∫•p)
                scoreDetails.sort((a, b) => b.score - a.score);

                let allAudioSequences = [];
                
                scoreDetails.forEach(detail => {
                    // L·∫§Y FILE AUDIO ƒê√É G√ÅN (normalized name ho·∫∑c member1-4)
                    const nameFile = detail.audioFile; 
                    const scoreFile = detail.score.toString(); 

                    if (detail.score < -10 || detail.score > 10) {
                        console.warn(`[C·∫¢NH B√ÅO AUDIO V√ÅN] ƒêi·ªÉm ${detail.score} c·ªßa ${detail.name} n·∫±m ngo√†i ph·∫°m vi ƒë·ªçc (-10 ƒë·∫øn 10) th√¥ng th∆∞·ªùng. H√£y ƒë·∫£m b·∫£o c√≥ file √¢m thanh "${scoreFile}.mp3".`);
                    }

                    // Chu·ªói ph√°t m·ªõi: [T√™n ng∆∞·ªùi ch∆°i audioFile], [ƒêi·ªÉm V√ÅN V·ª™A GHI]
                    const audioSequence = [nameFile, scoreFile];
                    
                    allAudioSequences.push(audioSequence);
                });
                
                addMultipleSequencesToQueue(allAudioSequences);
            };

            // Logic Audio 6a. Ph√°t th√¥ng b√°o v√°n c√≤n l·∫°i
            const playLowRoundAudio = useCallback((roundsLeft) => {
                let audioFile = null;
                if (roundsLeft === 3) {
                    audioFile = '3left';
                } else if (roundsLeft === 2) {
                    audioFile = '2left';
                } else if (roundsLeft === 1) {
                    audioFile = '1left';
                }
                if (audioFile) {
                    addToQueue([audioFile]);
                }
            }, [addToQueue]);


            // --- 5. L·ªãch s·ª≠ ƒëi·ªÉm v√† T·ªïng k·∫øt v√°n (useEffect ch√≠nh) ---
            useEffect(() => {
                const roundsLimit = parseInt(maxRounds);
                const currentRound = history.length;
                
                if (gameState !== 'playing' || roundsLimit <= 0) return;

                const roundsLeft = roundsLimit - currentRound;
                let delayTimer = null;

                // 1. Logic Game Over - KHI ƒê·∫†T GI·ªöI H·∫†N V√ÅN
                if (currentRound >= roundsLimit) {
                    setGameState('game_over');
                    addToQueue(['gameover']); 
                    return;
                }

                // 2. Logic Low Rounds Notification
                if (currentRound > 0) { 
                    delayTimer = setTimeout(() => {
                        playLowRoundAudio(roundsLeft);
                    }, 5000); 
                }
                
                return () => {
                    if (delayTimer) {
                        clearTimeout(delayTimer);
                    }
                };
            }, [history, maxRounds, gameState, players, addToQueue, playLowRoundAudio, unsortedPlayerScores]); 
            
            useEffect(() => {
                 if (players.length > 0 && gameState === 'playing' && Object.keys(roundScoreInputs).length === 0) {
                    const initialInputs = players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                    setRoundScoreInputs(initialInputs);
                }
            }, [players, gameState, roundScoreInputs]);


            // --- 7. Ho√†n t√°c (Undo) ---
            const confirmUndo = () => {
                const isFirstRound = history.length === 1;
                
                setHistory(prev => prev.slice(0, -1)); 
                setGameState('playing');
                setIsScoringMode(false);
                setRoundScoreInputs({});
                setModal({ isOpen: false, type: null, data: null });
                addToQueue(['hoantac']); 
                // B·ªé: sessionStorage.removeItem(`game_saved_${history.length}`); 

                // N·∫øu ho√†n t√°c v√°n ƒë·∫ßu ti√™n, ph·∫£i reset startTime
                if (isFirstRound) {
                    setStartTime(null);
                }
                // KH√îNG reset isGameSaved ·ªü ƒë√¢y v√¨ game v·∫´n c√≤n
            };
            
            const handleUndo = () => {
                if (history.length === 0 || isScoringMode) return;
                setModal({
                    isOpen: true,
                    type: 'confirm_action',
                    data: { action: 'Ho√†n T√°c V√°n Cu·ªëi', onConfirm: confirmUndo }
                });
            };

            // --- 8. Reset Game ---
            const confirmResetGame = () => {
                setGameState('setup');
                setPlayers([]);
                setHistory([]);
                setIsScoringMode(false);
                setRoundScoreInputs({});
                setMaxRounds(15); 
                
                // *** TH√äM M·ªöI: Reset startTime ***
                setStartTime(null); 
                
                // *** TH√äM M·ªöI: Reset c·ªù isGameSaved ***
                setIsGameSaved(false);
                // *** K·∫æT TH√öC TH√äM M·ªöI ***
                
                localStorage.clear(); 
                // B·ªé: Object.keys(sessionStorage).forEach...
                
                setModal({ isOpen: false, type: null, data: null });
            };
            
            const handleResetGame = () => {
                if (isScoringMode) return;
                setModal({
                    isOpen: true,
                    type: 'confirm_action',
                    data: { action: 'Reset Game', onConfirm: confirmResetGame }
                });
            };
            
            // --- 9. K·∫øt Th√∫c Game
             const handleEndGameConfirm = () => {
                if (isScoringMode) return;
                setModal({
                    isOpen: true,
                    type: 'confirm_action',
                    data: { 
                        action: 'K·∫øt Th√∫c Game', 
                        onConfirm: () => {
                            setGameState('game_over');
                            addToQueue(['gameover']); 
                            setModal({ isOpen: false, type: null, data: null });
                        }
                    }
                });
            };


            // --- X·ª≠ l√Ω Stage: Setup (Giai ƒëo·∫°n I) ---
            
            const handleAddPresetPlayer = (nameToAdd) => {
                if (!nameToAdd) return; 

                if (players.length >= MAX_PLAYERS) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Th√¥ng b√°o', message: `S·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i t·ªëi ƒëa l√† ${MAX_PLAYERS}.` }
                    });
                    return;
                }

                const trimmedName = nameToAdd.trim();
                if (players.some(p => p.name.toLowerCase() === trimmedName.toLowerCase())) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Th√¥ng b√°o', message: `Ng∆∞·ªùi ch∆°i '${trimmedName}' ƒë√£ t·ªìn t·∫°i.` }
                    });
                    return;
                }

                const newPlayer = createPlayerObject(trimmedName, false, players);
                setPlayers([...players, newPlayer]);
            };

            const handleRemovePlayer = (playerName) => {
                const existingPlayer = players.find(p => p.name === playerName); 
                if (existingPlayer) {
                    const newPlayers = players.filter(p => p.id !== existingPlayer.id);
                    setPlayers(newPlayers);
                }
            };
            
            const handleTogglePresetPlayer = (name) => {
                if (players.some(p => p.name === name)) {
                    handleRemovePlayer(name);
                } else {
                    handleAddPresetPlayer(name);
                }
            };


            const handleAddNewPlayer = () => {
                const trimmedName = newPlayerName.trim();
                if (!trimmedName) return;

                if (players.length >= MAX_PLAYERS) {
                     setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Th√¥ng b√°o', message: `S·ªë l∆∞·ª£ng ng∆∞·ªùi ch∆°i t·ªëi ƒëa l√† ${MAX_PLAYERS}.` }
                    });
                    return;
                }
                
                if (players.some(p => p.name.toLowerCase() === trimmedName.toLowerCase()) || PRESET_PLAYERS.some(p => p.toLowerCase() === trimmedName.toLowerCase())) {
                     setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'Th√¥ng b√°o', message: `Ng∆∞·ªùi ch∆°i '${trimmedName}' ƒë√£ t·ªìn t·∫°i.` }
                    });
                    return;
                }
                
                const newPlayer = createPlayerObject(trimmedName, true, players);
                setPlayers([...players, newPlayer]);
                setNewPlayerName('');
            };
            
            const handleStartGame = () => {
                if (players.length < 2) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'L·ªói', message: 'C·∫ßn t·ªëi thi·ªÉu 2 ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu tr√≤ ch∆°i.' }
                    });
                    return;
                }
                
                const finalMaxRounds = parseInt(maxRounds);
                if (isNaN(finalMaxRounds) || finalMaxRounds < 1) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'L·ªói', message: 'S·ªë v√°n ch∆°i ph·∫£i l√† m·ªôt s·ªë nguy√™n d∆∞∆°ng h·ª£p l·ªá (t·ªëi thi·ªÉu 1).' }
                    });
                    setMaxRounds(15); 
                    return;
                }

                setMaxRounds(finalMaxRounds); 
                setGameState('playing');
                const initialInputs = players.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                setRoundScoreInputs(initialInputs);
            };

            // --- X·ª≠ l√Ω Stage: Playing (Giai ƒëo·∫°n II) ---

            const handleNewScoreClick = () => {
                if (!isScoringMode) {
                    addToQueue(['vanmoi']); 
                    setIsScoringMode(true);
                    const initialInputs = unsortedPlayerScores.reduce((acc, p) => ({ ...acc, [p.id]: 0 }), {});
                    setRoundScoreInputs(initialInputs);
                } else {
                    handleConfirmScore();
                }
            };

            const handleScoreChange = (playerId, value) => {
                const numValue = value === '' ? '' : parseInt(value);
                setRoundScoreInputs(prev => ({ ...prev, [playerId]: isNaN(numValue) ? value : numValue }));
            };

            const handleConfirmScore = () => {
                const newRoundScores = {};

                unsortedPlayerScores.forEach(p => {
                    const score = roundScoreInputs[p.id];
                    if (score === '' || score === null || isNaN(score)) {
                        newRoundScores[p.id] = 0; 
                    } else {
                        newRoundScores[p.id] = parseInt(score); 
                    }
                });
                
                // *** TH√äM M·ªöI: Ghi startTime n·∫øu l√† v√°n 1 ***
                if (history.length === 0) {
                    setStartTime(new Date().toISOString());
                }
                // *** K·∫æT TH√öC TH√äM M·ªöI ***

                const newHistoryEntry = {
                    round: history.length + 1,
                    scores: newRoundScores,
                    timestamp: new Date().toISOString()
                };
                setHistory(prev => [...prev, newHistoryEntry]);

                playScoreAudio(newRoundScores);

                setIsScoringMode(false);
                setRoundScoreInputs({});
            };
            
            const handleSetRoundsClick = () => {
                if (isScoringMode) return;
                 setModal({
                    isOpen: true,
                    type: 'reset_rounds',
                    data: { currentMax: parseInt(maxRounds) || 15, playedRounds: history.length }
                });
                setNewMaxRoundsInput(parseInt(maxRounds) || 15);
            };

            const confirmResetRounds = () => {
                const newMax = parseInt(newMaxRoundsInput);
                if (isNaN(newMax) || newMax <= 0) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'L·ªói', message: 'S·ªë v√°n m·ªõi ph·∫£i l√† m·ªôt s·ªë nguy√™n d∆∞∆°ng h·ª£p l·ªá.' }
                    });
                    return;
                }
                if (newMax < history.length) {
                    setModal({
                        isOpen: true,
                        type: 'info',
                        data: { title: 'L·ªói', message: `S·ªë v√°n m·ªõi (${newMax}) kh√¥ng ƒë∆∞·ª£c nh·ªè h∆°n s·ªë v√°n ƒë√£ ch∆°i (${history.length}).` }
                    });
                    return;
                }
                
                setMaxRounds(newMax);
                setModal({ isOpen: false, type: null, data: null });
                addToQueue(['dasetsovan']); 
                
                if (history.length >= newMax) {
                    setGameState('game_over');
                    addToQueue(['gameover']); 
                }
            };

            const renderModalContent = () => {
                switch (modal.type) {
                    case 'info':
                        return <div><p className="text-gray-700">{modal.data.message}</p></div>;
                    case 'confirm_action': 
                        return <div><p className="text-gray-700 font-medium">X√°c nh·∫≠n **{modal.data.action}**?</p></div>;
                    case 'reset_rounds':
                        return (
                            <div>
                                <p className="text-gray-700 mb-4">
                                    V√°n ƒë√£ ch∆°i: <span className="font-bold text-primary">{modal.data.playedRounds}</span>.
                                    S·ªë v√°n t·ªëi thi·ªÉu ph·∫£i l√† <span className="font-bold text-primary">{modal.data.playedRounds}</span>.
                                </p>
                                <label className="block text-sm font-medium text-gray-700">Nh·∫≠p s·ªë v√°n m·ªõi:</label>
                                <input
                                    type="number"
                                    min={modal.data.playedRounds}
                                    value={newMaxRoundsInput}
                                    onChange={(e) => setNewMaxRoundsInput(e.target.value)}
                                    className="mt-1 block w-full p-2 border border-gray-300 rounded-md focus:ring-primary focus:border-primary"
                                />
                            </div>
                        );
                    default:
                        return null;
                }
            };

            // --- Render c√°c Stage ---
            
            // Stage 0: Setup
            const renderSetup = () => {
                
                // THAY ƒê·ªîI: T·∫°o danh s√°ch hi·ªÉn th·ªã bao g·ªìm c·∫£ ng∆∞·ªùi ch∆°i t√πy ch·ªânh
                const customPlayerNames = players
                    .map(p => p.name)
                    .filter(name => !PRESET_PLAYERS.includes(name));
                
                const displayList = [...PRESET_PLAYERS, ...customPlayerNames];

                // Ki·ªÉm tra xem s·ªë v√°n hi·ªán t·∫°i c√≥ ph·∫£i l√† gi√° tr·ªã t√πy ch·ªânh kh√¥ng
                const isCustomRound = !PRESET_ROUNDS.includes(parseInt(maxRounds));

                return (
                    <div className="p-4 sm:p-6 pb-2">
                        <h2 className="text-xl font-bold text-primary mb-4 text-center">‚öôÔ∏è C·∫•u H√¨nh Tr√≤ Ch∆°i</h2>

                        {/* Ch·ªçn S·ªë V√°n */}
                        <div className="mb-4 p-4 bg-white rounded-xl shadow-lg border border-indigo-100">
                            <h3 className="text-md font-semibold mb-3 text-gray-700 flex items-center">
                                1. Ch·ªçn S·ªë V√°n Ch∆°i 
                                <span className="ml-2 px-3 py-1 text-xs font-bold text-primary bg-indigo-100 rounded-full">
                                    Hi·ªán t·∫°i: {parseInt(maxRounds) || 15}
                                </span>
                            </h3>
                            
                            {/* ƒêI·ªÄU CH·ªàNH: ƒê∆∞a Input v√†o c√πng h√†ng v·ªõi c√°c n√∫t */}
                            <div className="flex flex-wrap gap-2 items-center"> 
                                {PRESET_ROUNDS.map(r => (
                                    <button
                                        key={r}
                                        onClick={() => setMaxRounds(r)}
                                        className={`px-3 py-1 text-sm font-medium rounded-full transition duration-200 shadow-md ${parseInt(maxRounds) === r ? 'bg-primary text-white font-bold' : 'bg-gray-200 text-gray-700'} flex-shrink-0`}
                                    >
                                        {r} V√°n
                                    </button>
                                ))}
                                
                                {/* Custom Input Button/Box t√≠ch h·ª£p v√†o flex container */}
                                {/* T·ªëi ∆∞u h√≥a: B·ªè flex-grow, gi·∫£m min-w ƒë·ªÉ v·ª´a h∆°n tr√™n mobile */}
                                <div className="min-w-[70px] flex-1"> 
                                    <input
                                        type="number"
                                        min="1"
                                        value={maxRounds} 
                                        onChange={(e) => setMaxRounds(e.target.value)} 
                                        onBlur={(e) => {
                                            const val = parseInt(e.target.value);
                                            if (isNaN(val) || val < 1) {
                                                setMaxRounds(1);
                                            } else {
                                                setMaxRounds(val);
                                            }
                                        }}
                                        // Styling m·ªõi ƒë·ªÉ h√≤a h·ª£p v√† nh·∫•n m·∫°nh khi l√† t√πy ch·ªânh
                                        className={`w-full px-3 py-1 text-sm font-medium border-2 rounded-full text-center shadow-md 
                                                    ${isCustomRound ? 'bg-indigo-100 border-primary text-primary font-bold' : 'bg-gray-200 border-gray-300 text-gray-700'} 
                                                    focus:ring-secondary focus:border-secondary transition`}
                                        placeholder="V√°n..."
                                    />
                                </div>
                            </div>
                        </div>
                        
                        {/* Ch·ªçn Ng∆∞·ªùi Ch∆°i */}
                        <div className="mb-4 p-4 bg-white rounded-xl shadow-lg border border-emerald-100">
                            <h3 className="text-md font-semibold mb-3 text-gray-700">2. Th√™m Ng∆∞·ªùi Ch∆°i ({players.length}/{MAX_PLAYERS})</h3>
                            
                            {/* L∆∞·ªõi 2 c·ªôt cho ng∆∞·ªùi ch∆°i */}
                            <div className="grid grid-cols-2 gap-2 mb-4">
                                {displayList.map(name => {
                                    const isSelected = players.some(p => p.name === name);
                                    const isDisabled = !isSelected && players.length >= MAX_PLAYERS;
                                    
                                    return (
                                        <button
                                            key={name}
                                            onClick={() => handleTogglePresetPlayer(name)}
                                            disabled={isDisabled}
                                            className={`p-2 rounded-lg border-2 transition-all duration-200 ease-in-out 
                                                        flex items-center justify-center relative text-sm font-medium text-center
                                                        ${isSelected 
                                                            ? 'bg-secondary border-secondary/50 text-white font-bold shadow-lg'
                                                            : 'bg-secondary/10 border-secondary/30 text-gray-700'}
                                                        ${isDisabled ? 'opacity-50 cursor-not-allowed bg-gray-100 border-gray-200' : ''}
                                                    `}
                                        >
                                            {isSelected && (
                                                <span className="absolute -top-2 -right-2 bg-white text-secondary rounded-full w-5 h-5 flex items-center justify-center text-sm font-bold border border-secondary/50">‚úì</span>
                                            )}
                                            {name}
                                        </button>
                                    );
                                })}
                            </div>

                            {/* Th√™m ng∆∞·ªùi ch∆°i m·ªõi (T√πy ch·ªânh) */}
                            <div className="flex space-x-2 mt-3 pt-3 border-t border-gray-100">
                                <input
                                    type="text"
                                    value={newPlayerName}
                                    onChange={(e) => setNewPlayerName(e.target.value)}
                                    placeholder="T√™n ng∆∞·ªùi ch∆°i t√πy ch·ªânh..."
                                    className="flex-grow p-2 text-sm border-2 border-gray-300 rounded-lg focus:ring-primary focus:border-primary disabled:bg-gray-100"
                                    disabled={players.length >= MAX_PLAYERS}
                                />
                                <button
                                    onClick={handleAddNewPlayer}
                                    className="p-2 bg-primary text-white rounded-lg font-semibold text-sm transition disabled:bg-gray-400"
                                    disabled={!newPlayerName.trim() || players.length >= MAX_PLAYERS}
                                >
                                    Th√™m
                                </button>
                            </div>
                            
                        </div>

                        {/* N√∫t B·∫Øt ƒë·∫ßu */}
                        <button
                            onClick={handleStartGame}
                            disabled={players.length < 2}
                            className="w-full py-4 bg-secondary text-white font-extrabold text-lg rounded-xl shadow-2xl transition duration-300 transform disabled:bg-gray-400 mt-6"
                        >
                            {players.length < 2 ? 'C·∫ßn 2 ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu' : `B·∫ÆT ƒê·∫¶U TR√í CH∆†I (${parseInt(maxRounds) || 15} V√ÅN)`}
                        </button>
                    </div>
                );
            };


            // Stage 1: Playing
            const renderPlaying = () => (
                <div className="p-4"> 
                    <h2 className="text-2xl font-extrabold text-primary mb-3 text-center"> 
                        V√ÅN <span className="text-secondary">{history.length + 1}</span> / {parseInt(maxRounds) || 15}
                    </h2>
                    
                    {/* N√∫t Ghi/X√°c nh·∫≠n ƒëi·ªÉm */}
                     <button
                        onClick={handleNewScoreClick}
                        className={`w-full py-3 font-extrabold text-white rounded-xl shadow-xl transition duration-300 transform mb-4 
                            ${isScoringMode ? 'bg-secondary animate-pulse-strong text-lg' : 'bg-primary text-base'}`} 
                        disabled={unsortedPlayerScores.length === 0}
                    >
                        {isScoringMode ? `‚úÖ X√ÅC NH·∫¨N GHI ƒêI·ªÇM V√ÅN ${history.length + 1}` : 'GHI ƒêI·ªÇM V√ÅN M·ªöI'}
                    </button>
                    
                    {/* V√πng Hi·ªán Th·ªã T√™n Ng∆∞·ªùi Ch∆°i v√† Ghi ƒêi·ªÉm */}
                    <div className={`p-4 rounded-xl shadow-xl mb-4 transition duration-500 
                                     ${isScoringMode ? 'bg-indigo-50 border-4 border-indigo-200 animate-fade-in' : 'bg-white border-2 border-gray-200'}`}> 
                        <h3 className="text-xl font-bold text-gray-700 mb-3 border-b pb-2"> 
                            {isScoringMode ? '‚úèÔ∏è Nh·∫≠p ƒêi·ªÉm V√°n M·ªõi' : 'üë• Ng∆∞·ªùi Ch∆°i'}
                        </h3>
                        <div className="space-y-3"> 
                            {unsortedPlayerScores.map(p => ( 
                                <div key={p.id} className="flex justify-between items-center py-1 bg-white p-3 rounded-lg shadow-md border border-gray-100">
                                    {/* T√™n ng∆∞·ªùi ch∆°i */}
                                    <div className={`flex items-center ${isScoringMode ? 'w-1/2' : 'flex-grow'}`}>
                                        <span className={`text-lg font-bold ${isScoringMode ? 'text-gray-800' : 'text-primary'} truncate`}>
                                            {p.name}
                                        </span>
                                    </div>
                                    
                                    {/* Scoring Input/Controls */}
                                    {isScoringMode && (
                                        <div className="grid grid-cols-3 w-1/2 gap-1.5">
                                            {/* N√∫t Gi·∫£m */}
                                            <button 
                                                onClick={() => handleScoreChange(p.id, (parseInt(roundScoreInputs[p.id]) || 0) - 1)}
                                                className="p-2 bg-danger text-white rounded-xl font-extrabold text-xl transition duration-150 shadow-md" 
                                            >
                                                -
                                            </button>
                                            {/* Input ƒêi·ªÉm */}
                                            <input
                                                type="number"
                                                value={roundScoreInputs[p.id] === 0 && roundScoreInputs[p.id] !== '' ? '0' : roundScoreInputs[p.id]}
                                                onChange={(e) => handleScoreChange(p.id, e.target.value)}
                                                className="p-1 border-2 border-secondary rounded-xl text-center font-mono text-xl font-bold focus:ring-secondary focus:border-secondary"
                                                placeholder="0"
                                            />
                                            {/* N√∫t TƒÉng */}
                                            <button 
                                                onClick={() => handleScoreChange(p.id, (parseInt(roundScoreInputs[p.id]) || 0) + 1)}
                                                className="p-2 bg-secondary text-white rounded-xl font-extrabold text-xl transition duration-150 shadow-md" 
                                            >
                                                +
                                            </button>
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>
                    
                    
                    {/* C√°c n√∫t ch·ª©c nƒÉng (grid 2x2) */}
                    <div className="grid grid-cols-2 gap-2 mb-4"> 
                        {/* H√†ng 1 */}
                        <button
                            onClick={handleSetRoundsClick} 
                            disabled={isScoringMode}
                            className="w-full py-3 bg-blue-600 text-white font-bold rounded-xl transition duration-200 disabled:bg-gray-400 text-sm shadow-md"
                        >
                            üîÅ Set V√°n
                        </button>
                         <button
                            onClick={handleUndo} 
                            disabled={history.length === 0 || isScoringMode}
                            className="w-full py-3 bg-warning text-white font-bold rounded-xl transition duration-200 disabled:bg-gray-400 text-sm shadow-md"
                        >
                            ‚Ü©Ô∏è Ho√†n T√°c
                        </button>
                        
                        {/* H√†ng 2 */}
                        <button
                            onClick={handleResetGame} 
                            disabled={isScoringMode}
                            className="w-full py-3 bg-danger text-white font-bold rounded-xl transition duration-200 disabled:bg-gray-400 text-sm shadow-md"
                        >
                            üîÑ Reset
                        </button>
                        <button
                            onClick={handleEndGameConfirm} 
                            disabled={isScoringMode}
                            className="w-full py-3 bg-gray-600 text-white font-bold rounded-xl transition duration-200 disabled:bg-gray-400 text-sm shadow-md"
                        >
                            üõë K·∫øt Th√∫c
                        </button>
                    </div>
                    
                    
                    {/* L·ªãch s·ª≠ ƒëi·ªÉm */}
                    <div className="bg-white p-4 rounded-xl shadow-xl border border-gray-200"> 
                        <button 
                            onClick={() => setShowHistory(prev => !prev)}
                            className="w-full text-left text-lg font-bold text-gray-700 p-1 rounded-lg transition flex justify-between items-center"
                        >
                            L·ªãch S·ª≠ ƒêi·ªÉm Chi Ti·∫øt ({history.length} V√°n) {showHistory ? '‚ñ≤' : '‚ñº'}
                        </button>
                        {showHistory && (
                            <div className="overflow-x-auto mt-3 max-h-60 border rounded-lg"> 
                                <table className="min-w-full divide-y divide-gray-200">
                                    <thead className="bg-gray-100 sticky left-0 z-10">
                                        <tr>
                                            <th className="px-3 py-2 text-left text-xs font-bold text-gray-600 uppercase sticky left-0 bg-gray-100 shadow-sm min-w-[100px]">Ng∆∞·ªùi ch∆°i</th>
                                            {[...Array(history.length)].map((_, index) => (
                                                <th key={index} className="px-3 py-2 text-center text-xs font-bold text-gray-600 uppercase min-w-[50px]">V√°n {history.length - index}</th>
                                            ))}
                                        </tr>
                                    </thead>
                                    <tbody className="bg-white divide-y divide-gray-200">
                                        {players.map(p => (
                                            <tr key={p.id}>
                                                <td 
                                                    className="px-3 py-2 whitespace-nowrap text-sm font-semibold text-gray-900 sticky left-0 bg-white shadow-sm truncate" 
                                                    title={p.name}
                                                >
                                                    {p.name}
                                                </td>
                                                {[...history].reverse().map(entry => {
                                                    const score = entry.scores[p.id] || 0;
                                                    const colorClass = score > 0 ? 'text-secondary font-extrabold' : (score < 0 ? 'text-danger font-semibold' : 'text-gray-500');
                                                    return (
                                                        <td key={entry.round} className={`px-3 py-2 whitespace-nowrap text-sm text-center ${colorClass} min-w-[50px] font-mono`}>
                                                            {score > 0 ? `+${score}` : score}
                                                        </td>
                                                    );
                                                })}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </div>
                </div>
            );

            // Stage 2: Game Over
            const renderGameOver = () => {
                const playerCount = sortedScores.length;
                
                let loserScoreThreshold = null;
                if (playerCount >= 2) {
                    loserScoreThreshold = sortedScores[playerCount - 2].totalScore;
                }

                const isLoser = (p) => {
                    if (loserScoreThreshold === null) return false;
                    return p.totalScore <= loserScoreThreshold;
                };

                return (
                    <div className="p-4 text-center animate-bounce-in">
                        <h2 className="text-2xl font-extrabold text-danger mb-1">üéâ TR√í CH∆†I K·∫æT TH√öC! üéâ</h2>
                        <p className="text-base font-medium text-gray-700 mb-3">T·ªïng s·ªë v√°n ƒë√£ ch∆°i: <span className="text-primary font-bold">{history.length}</span></p>

                        {/* B·∫£ng X·∫øp H·∫°ng */}
                        <div className="bg-white p-4 rounded-xl shadow-2xl mb-4 border border-indigo-200">
                            <h3 className="text-xl font-extrabold text-primary mb-3 border-b pb-2">üèÜ B·∫¢NG X·∫æP H·∫†NG</h3>
                            {sortedScores.map((p, index) => {
                                const isCurrentLoser = isLoser(p);
                                
                                const itemClassName = `flex justify-between items-center py-2 px-3 my-2 rounded-xl transition transform duration-300 shadow-md 
                                                       ${isCurrentLoser ? 'bg-red-100 border-2 border-danger scale-[1.03]' : 'bg-gray-50 border-2 border-secondary/50'}`;
                                
                                return (
                                    <div 
                                        key={p.id} 
                                        className={itemClassName}
                                    >
                                        <div className="flex items-center space-x-2">
                                            <span className={`text-xl font-extrabold w-6 text-center 
                                                              ${index === 0 ? 'text-yellow-500' : index === 1 ? 'text-gray-400' : index === 2 ? 'text-amber-700' : 'text-primary'}`}>
                                                #{index + 1}
                                            </span>
                                            <span className={`text-lg font-bold ${isCurrentLoser ? 'text-danger' : 'text-gray-700'}`}>
                                                {p.name}
                                            </span>
                                        </div>
                                        <span className={`text-2xl font-extrabold ${p.totalScore >= 0 ? 'text-secondary' : 'text-danger'} font-mono`}>
                                            {p.totalScore}
                                        </span>
                                    </div>
                                );
                            })}
                        </div>

                        {/* L·ªãch s·ª≠ ƒëi·ªÉm t·∫°i m√†n h√¨nh Game Over */}
                        <div className="bg-white p-3 rounded-xl shadow-lg mb-4 border border-gray-200">
                            <button 
                                onClick={() => setShowGameOverHistory(prev => !prev)}
                                className="w-full text-left text-lg font-bold text-gray-700 p-1 rounded-lg transition flex justify-between items-center"
                            >
                                L·ªãch S·ª≠ ƒêi·ªÉm Chi Ti·∫øt ({history.length} V√°n) {showGameOverHistory ? '‚ñ≤' : '‚ñº'}
                            </button>
                            {showGameOverHistory && (
                                <div className="overflow-x-auto mt-2 max-h-48 border rounded-lg">
                                    <table className="min-w-full divide-y divide-gray-200">
                                        <thead className="bg-gray-100 sticky left-0 z-10">
                                            <tr>
                                                <th className="px-3 py-2 text-left text-xs font-bold text-gray-600 uppercase sticky left-0 bg-gray-100 shadow-sm min-w-[100px]">Ng∆∞·ªùi ch∆°i</th>
                                                {[...Array(history.length)].map((_, index) => (
                                                    <th key={index} className="px-3 py-2 text-center text-xs font-bold text-gray-600 uppercase min-w-[50px]">V√°n {history.length - index}</th>
                                                ))}
                                            </tr>
                                        </thead>
                                        <tbody className="bg-white divide-y divide-gray-200">
                                            {players.map(p => (
                                                <tr key={p.id}>
                                                    <td 
                                                        className="px-3 py-2 whitespace-nowrap text-sm font-semibold text-gray-900 sticky left-0 bg-white shadow-sm truncate" 
                                                        title={p.name}
                                                    >
                                                        {p.name}
                                                    </td>
                                                    {[...history].reverse().map(entry => {
                                                        const score = entry.scores[p.id] || 0;
                                                        const colorClass = score > 0 ? 'text-secondary font-extrabold' : (score < 0 ? 'text-danger font-semibold' : 'text-gray-500');
                                                        return (
                                                            <td key={entry.round} className={`px-3 py-2 whitespace-nowrap text-sm text-center ${colorClass} min-w-[50px] font-mono`}>
                                                                {score > 0 ? `+${score}` : score}
                                                            </td>
                                                        );
                                                    })}
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            )}
                        </div>

                        {/* N√∫t Ch∆°i L·∫°i */}
                        <button
                            onClick={confirmResetGame} 
                            className="w-full py-3 bg-secondary text-white font-extrabold text-xl rounded-xl shadow-xl transition transform"
                        >
                            CH∆†I L·∫†I
                        </button>
                    </div>
                );
            };
            
            // --- Logic Render Ch√≠nh ---

            return (
                <div className="min-h-screen bg-gray-50 flex justify-center">
                    <div className="w-full max-w-xl mx-auto bg-white shadow-3xl rounded-2xl overflow-hidden my-0 sm:my-6">
                        <header className="bg-primary text-white p-4 text-center">
                            {/* Thay ƒë·ªïi ti√™u ƒë·ªÅ ch√≠nh */}
                            <h1 className="text-3xl font-extrabold">TI·∫æN L√äN MI·ªÄN TRUNG</h1> 
                        </header>
                        
                        {gameState === 'setup' && renderSetup()}
                        {gameState === 'playing' && renderPlaying()}
                        {gameState === 'game_over' && renderGameOver()}
                    </div>

                    {/* Modal Popup */}
                    <Modal
                        title={modal.type === 'info' ? 'Th√¥ng b√°o' : 
                               modal.type === 'confirm_action' ? 'X√°c nh·∫≠n' : 'Set l·∫°i S·ªë V√°n Ch∆°i'}
                        isOpen={modal.isOpen}
                        onClose={() => setModal({ isOpen: false, type: null, data: null })}
                        onConfirm={modal.type === 'confirm_action' ? modal.data.onConfirm : 
                                   modal.type === 'reset_rounds' ? confirmResetRounds :
                                   () => setModal({ isOpen: false, type: null, data: null }) 
                                  }
                        confirmText={modal.type === 'info' ? 'ƒê√≥ng' : 'X√°c nh·∫≠n'}
                        showCancel={modal.type !== 'info'}
                        content={renderModalContent()}
                    />
                </div>
            );
        }

        // Render ·ª©ng d·ª•ng React v√†o DOM
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
